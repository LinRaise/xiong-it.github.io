{"meta":{"title":"MichaelX's Blog","subtitle":"MichaelX的开发博客","description":"求索技术之道，追寻代码之美","author":"MichaelX","url":"https://xiong-it.github.io"},"pages":[{"title":"","date":"2017-01-12T11:57:43.000Z","updated":"2017-05-03T08:21:21.756Z","comments":true,"path":"about/index.html","permalink":"https://xiong-it.github.io/about/index.html","excerpt":"","text":"国内某知名互联网公司不知名程序员，主要从事Android领域Application开发。轻微代码洁癖患者，google粉，喜欢编程和分享，仅此。 人生格言：求索技术之道，追寻代码之美。共勉！"},{"title":"分类","date":"2017-01-12T12:24:55.000Z","updated":"2017-05-03T08:21:21.756Z","comments":false,"path":"categories/index.html","permalink":"https://xiong-it.github.io/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2017-01-12T12:24:39.000Z","updated":"2017-05-03T08:21:21.756Z","comments":false,"path":"tags/index.html","permalink":"https://xiong-it.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"科学上网:安装Shadowsocks Server on VPS","slug":"科学上网-安装Shadowsocks-Server-on-VPS","date":"2017-05-03T08:46:37.000Z","updated":"2017-05-12T09:22:41.635Z","comments":true,"path":"2017/05/03/科学上网-安装Shadowsocks-Server-on-VPS/","link":"","permalink":"https://xiong-it.github.io/2017/05/03/科学上网-安装Shadowsocks-Server-on-VPS/","excerpt":"作为一名开发者，科学上网是一个很强的诉求，至今被|墙的google，偶尔抽风的github，当然你要想着看小片，全球最大的xx网站也在墙外","text":"作为一名开发者，科学上网是一个很强的诉求，至今被|墙的google，偶尔抽风的github，当然你要想着看小片，全球最大的xx网站也在墙外 前言作为一名开发者，科学上网是一个很强的诉求，至今被|墙的google，偶尔抽风的github，当然你要想着看小片，全球最大的xx网站也在墙外。科学-上网的方法大致如下几种： 修改本机hosts，可访问的网站有限 v-p-n：容易被封 shadow-socks-俗称：c etc… 简单介绍其中修改hosts的方法成本最低，也最简单，网上找到需要访问网站的ip，写进本机hosts文件中即可。这样访问被|墙网站时，机器先访问hosts文件，发现已经有ip了，就不会访问dns服务器去要求解析域名了，而是直接根据指定ip去访问被|墙网站。v-p-n的方式由于其容易被探测的缘故，容易被封。根据socks5代理方式实现的shadow-socks项目，由于其隐蔽性存活至今。其需要一外国的服务器上装shadow-socks服务端实现流量中转，然后本地机器装shadow-socks客户端进行科学上网。当然网上也有很多的shadow-socks账号购买，服务器它给你搭好了，然后就售卖账号，但是也存在些骗子收完钱跑路的，拿着账号上不了网，当然也存在奸商超售账号的情况，许多人买完账号挤在一个服务器上爬蜗牛。那么为什么不自己搭一个shadow-socks服务端呢？更何况年付的价钱不比你购买账号贵！服务器还在自己手里，不怕隐私泄露。 什么是vps笔者理解也不深，感觉就是虚拟主机的升级版，可拥有独立ip，但又不是独立服务器，是一台服务器上利用虚拟化技术独立出来的单独机器，购买这台vps后，你自己就可以对这台机器做任意操作：重装系统（Linux，Windows），装任意软件，拥有root权限，可远程操控都不在话下。总之和一台远程服务器差不多。但是价格却远低于服务器价格。搬瓦工VPS的介绍翻译如下： 隶属于美国IT7公司旗下的一款低价OpenVZ VPS主机方案、2017年新增KVM VPS架构，尤其是6款便宜年付VPS，无论从性价比还是稳定性都非常适合大众VPS用户需求，我们可以用来建站、搭建上网环境 官网：性价比高*搬瓦工vps 笔者购买的是最便宜的年付19刀（人民币130左右）的512M内存，10G ssd硬盘，100G宽带方案，难能可贵的是搬瓦工vps：可使用支付宝支付，据说是2016年推出的新功能，之前只能使用PayPal支付。 购买搬瓦工VPS 打开搬瓦工官网：性价比高*搬瓦工vps 点击要购买的的套餐下方的 订购按钮“order Now”， 进入如下图示界面，选择付账周期Billing Cycle（月付，季付，半年付，年付），和节点Location（洛杉矶，佛罗里达等），洛杉矶的节点还行，比较稳定。最后点击Add to Cart加入购物车，之后下一个界面点击check out结账。 注册账号有几点： 资料是否完全真实无所谓，姓名可以随意填 邮箱必须自己的，以免以后找回密码需要 国家、地区、省份必须真实 街道等详细地址你随意填写，电话也可以随意。不能用V=P=N软件更换IP购买，用真实的IP购买就可以。 Pay Method中选择Alipay即支付宝，勾选下方的协议 点击Complete Order结账 手机支付宝扫二维码，完事 搬瓦工VPS安装shadowsocks服务端 点击图中的Client Area，登陆账号 查看服务 点击右边的KiviVM Control Panel进入vps控制面板 安装Shadow-socks Server ss客户端使用ss客户端下载ss客户端使用 参考博客https://b.lhuac.com/2/","categories":[{"name":"科学上网","slug":"科学上网","permalink":"https://xiong-it.github.io/categories/科学上网/"}],"tags":[{"name":"科学上网","slug":"科学上网","permalink":"https://xiong-it.github.io/tags/科学上网/"},{"name":"Shadowsocks","slug":"Shadowsocks","permalink":"https://xiong-it.github.io/tags/Shadowsocks/"}]},{"title":"Ubuntu 14.04编译AOSP for Nexus/Pixel","slug":"Ubuntu-14-04编译AOSP-for-Nexus-Pixel","date":"2017-03-14T03:29:09.000Z","updated":"2017-05-03T08:21:21.752Z","comments":true,"path":"2017/03/14/Ubuntu-14-04编译AOSP-for-Nexus-Pixel/","link":"","permalink":"https://xiong-it.github.io/2017/03/14/Ubuntu-14-04编译AOSP-for-Nexus-Pixel/","excerpt":"为你手中的Nexus,Pixel手机刷入自己的专属Rom","text":"为你手中的Nexus,Pixel手机刷入自己的专属Rom 前言虽说几年前博主在一家公司做机顶盒的时候总是需要编译Android源码，但是那时还没有手中的爱机：Nexus 6，又名shamu。今天我要为它刷入一个自己编译的Rom。拿起键盘就是干。 笔者注：AOSP:Android Open Source Project，安卓开源项目 准备 Ubuntu 14.04+ OpenJDK/JDK Nexus/Pixel手机一部 假设你已经有了一个较新的Ubuntu系统和一部谷歌亲儿子手机，下文将从安装jdk开始。 本文作者MichaelX，博客地址：http://blog.csdn.net/xiong_it ，转载请注明出处。 AOSP编译环境搭建安装OpenJDK 警告：不要使用oracle jdk来编译较新（API 21+/Android 5.0及以上）的AOSP，会在准备编译工作make clobber时出现错误提示. Checking build tools versions... ************************************************************* You asked for an OpenJDK based build but your version is java version &quot;1.8.0_121&quot; Java(TM) SE Runtime Environment(build 1.8.0_121-b13)Java HotSpot (TM)64 bit Server VM(build 25.121-b13), mixed mode). ************************************************************* build/core/main.mk:230: *** stop. 关于JDK版本的选择：根据你想编译的Android版本来决定 AOSP最新源码: OpenJDK 8 Android 5.x (Lollipop) - Android 6.0 (Marshmallow):OpenJDK 7 Android 2.3.x (Gingerbread) - Android 4.4.x(KitKat):Java JDK 6 Android 1.5 (Cupcake) - Android 2.2.x (Froyo): Java JDK 5 博主想要编译的是Android 7.0，所以需要使用是OpenJDK 8。 博主是用的Ubuntu 14.04 LTS，可采取安装deb包或者添加ppa两种方式安装OpenOJDK 8： OpenJDK deb包下载:OpenJDK 8 on github 添加ppa方式安装OpenJDK1234567$ sudo add-apt-repository ppa:openjdk-r/ppa$ sudo apt-get update$ sudo apt-get install openjdk-8-jdk$ sudo update-alternatives --config java$ sudo update-alternatives --config javac 假如你Ubuntu是15.04或者更新的系统，可直接运行下列命令进行OpenJDK 8安装 12$ sudo apt-get update$ sudo apt-get install openjdk-8-jdk Linux使用下列命令查看机器中所有jdk版本123$ michaelx@michaelx-ThinkPad:~/AOSP_NBD91Z$ update-java-alternatives -l// 打印出下面已安装的jdk版本java-1.8.0-openjdk-amd64 1069 /usr/lib/jvm/java-1.8.0-openjdk-amd64 Linux设置默认JDK命令123456// 设置默认为openjdk8，此处必须选用OpenJDK8$ sudo update-java-alternatives -s java-1.8.0-openjdk-amd64// 设置默认为oracle jdk8$ sudo update-java-alternatives -s java-8-oracle// 设置默认为oracle jdk7$ sudo update-java-alternatives -s java-7-oracle Ubuntu 14.04设置默认OpenJDK 8时出现一处警告提示： update-java-alternatives: plugin alternative does not exist: /usr/lib/jvm/java-8-openjdk-amd64/jre/lib/amd64/IcedTeaPlugin.so 该提示无需理会，可直接忽略。 查看Java版本，出现以下提示，说明jdk环境已经ok。12345$ java -versionopenjdk version &quot;1.8.0_111&quot;OpenJDK Runtime Environment (build 1.8.0_111-8u111-b14-3~14.04.1-b14)OpenJDK 64-Bit Server VM (build 25.111-b14, mixed mode) 如果实在切换不了默认jdk，就像博主一样，卸了oracle jdk吧。 安装必要软件在你的Ubuntu 14(x64)上执行以下命令1234$ sudo apt-get install git-core gnupg flex bison gperf build-essential \\ zip curl zlib1g-dev gcc-multilib g++-multilib libc6-dev-i386 \\ lib32ncurses5-dev x11proto-core-dev libx11-dev lib32z-dev ccache \\ libgl1-mesa-dev libxml2-utils xsltproc unzip 会有些已经安装，有些无法安装，或者安装失败，无需理会，继续往下。其他系统版本系统请直接参考：Establishing a build environment 配置USB访问权限ps：不知道这个干啥的，但是官方是这么建议的，为了让普通用户可访问usb设备。1$ wget -S -O - http://source.android.com/source/51-android.rules | sed &quot;s/&lt;username&gt;/$USER/&quot; | sudo tee &gt;/dev/null /etc/udev/rules.d/51-android.rules; sudo udevadm control --reload-rules 安装repo安装repo以下载AOSP源码。repo是Google根据git开发来专门管理Android源码用的，具有断点续传的特性。其主要命令可参考：git/repo常用命令一览。依次执行下面命令。123456$ cd ~$ mkdir bin$ PATH=~/bin:$PATH$ curl https://storage.googleapis.com/git-repo-downloads/repo &gt; ~/bin/repo$ chmod a+x ~/bin/repo # 给repo添加执行权限 配置git由于需要下载Android源码，你需要事先准备好一个google的gmail邮箱。执行以下命令配置git用户名和gmail邮箱。12$ git config --global user.name &quot;Your Name&quot;$ git config --global user.email &quot;you@gmail.com&quot; 配置Google的git cookies访问权限，以便大量下载aosp源码站点资源。https://android.googlesource.com/new-password configure 复制框中的命令,粘贴到终端,执行。 下载AOSP源码创建一个目录以存放Android源码12$ mkdir ~/AOSP_NBD91Z # 目录名请自行定义，本文以AOSP_NBD91ZNBD91Z为例$ cd AOSP_NBD91Z 根据手中的机器和以下两个连接进行repo分支选择：https://source.android.com/source/build-numbers.htmlhttps://developers.google.com/android/nexus/drivers AOSP源码编译默认是不适配驱动的，只适合模拟器运行，由于博主想要为Nexus 6编译，所以需要考虑驱动问题，根据上文第二个链接找到shamu的最新驱动，目前（20170307）最新的驱动支持到build NBD91Z，将驱动下载下来，留着备用。 这里写图片描述 在第一个链接中找到对应的branch name（android-7.0.0_r29）。 这里写图片描述 在AOSP本地目录初始化repo分支12$ cd ~/AOSP_NBD91Z$ repo init -u https://android.googlesource.com/platform/manifest -b android-7.0.0_r29 下载/续传AOSP源码无论是第一次开始下载，还是中途断掉后接着续传下载，都是执行以下命令。1$ repo sync 之后就是漫长的等待了，该分支（android-7.0.0_r29）代码总共约80G（含版本管理文件.repo目录46G）。这里提醒下各位，分区的时候一定记得至少至少至少给到120G啊，80G还不是最新分支的大小呢。编译后更加大得多：该分支编译出的out目录共30G左右。 这里写图片描述 不过下载完成后，如果没什么版本控制的需要 .repo目录倒是可以删除掉，节省点硬盘空间。 编译AOSP预备工作设置编译缓存（可选操作）可加速后续第二次编译，如需要，可在源码目录执行以下命令123$ export USE_CCACHE=1$ export CCACHE_DIR=~/AOSP_NBD91Z/.ccache # 目录自定义$ prebuilts/misc/linux-x86/ccache/ccache -M 50G # 官方推荐50-100G 更新环境变量12345$ vim ~/.bashrc# 添加以下这行export USE_CCACHE=1$ source ~/.bashrc 释放手机驱动将上述下载的几个驱动文件解压到源码根目录，解压后也就是几个脚本文件，依次执行，以释放驱动，画风大概如下{% image http://img.blog.csdn.net/20170312141135768?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvWGlvbmdfSVQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast 释放shamu驱动 %} {% image http://img.blog.csdn.net/20170312213814287?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvWGlvbmdfSVQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast 释放shamu驱动 %} {% image http://img.blog.csdn.net/20170312184550739?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvWGlvbmdfSVQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast 释放shamu驱动 %} 共8大条款，几十个小条款，一行行回车按过去，心累啊。 划重点：在执行驱动脚本后，会让你看一大长串协议，最后你需要输入：I ACCEPT 来同意驱动的协议，方可释放驱动文件。按回车按快了则提示你没有同意，驱动未释放成功。成功之后会多出一个vendor目录。 清理编译文件驱动释放完毕，先执行make clobber清理下编译后文件的目录，第一次编译其实博主觉得这个命令无所谓。 相似命令：make clean 它清理out/target/product/[product_name]目录。 编译AOSP准备好编译平台1234$ cd AOSP_NBD91Z$ source build/envsetup.sh# or 或者，上面的命令和下面的命令等价$ . build/envsetup.sh 选择编译平台执行上述命令后方可执行这条命令lunch lunch 由于笔者手中是Nexus 6（shamu），所以果断选择了21 关于几种模式的区别 user 正常模式，给普通用户用的 userdebug 具备root权限和更多调试功能，其他和user模式无异 eng 开发者的最佳选项，具有许多额外的调试工具 正式编译AOSP源码运行make进行编译，也可以使用-j选项指定并行编译线程数量1234# 利用6个线程进行编译。官方建议的最快并行线程数量为：j16-j32之间。$ make -j6 # 请各位根据自身CPU性能量力而行。博主曾经使用-j16导致GUI界面和终端统统卡死，只能强制关机，心疼我的ssd硬盘30s。 又是一次漫长的等待啊，如果不出什么问题，那么在out/target/product/[product_name]/目录下将会多出诸如system.img，recovery.img等等，就可以愉快的刷机了。 build-aosp-successful 下面是生成的各种镜像文件和其他。 out-dir-files 编译AOSP遇到的问题权限遭拒由于博客使用了外部硬盘作为out编译输出，make时提示Permission is denied。这时换成sudo make即可。 使用外部磁盘做out输出：export OUT_DIR_COMMON_BASE=/media/username/外部磁盘路径/out 内存不足由于笔者的内存只有4G，并且最开始没有分出swap分区，导致多次内存不足编译失败，有多种日志形式都表明内存不足： 第1种错误：[ 34% 12287/35393] Building with Jack: out/target/common/obj/JAVA_LIBRARIES/core-all_intermediates/with-local/classes.dex FAILED: /bin/bash out/target/common/obj/JAVA_LIBRARIES/core-all_intermediates/with-local/classes.dex.rsp Communication error with Jack server (52). Try &#39;jack-diagnose&#39; ninja: build stopped: subcommand failed. make: *** [ninja_wrapper] Error 1 第2种错误：[ 82% 30024/36285] Aligning zip: out/target/product/shamu/obj/SHARED_LIBRARIES/libdlext_test_runpath_zip_zipaligned_intermediates/libdlext_test_runpath_zip_zipaligned.zip [ 82% 30025/36285] Import includes file: out/target/product/shamu/obj/STATIC_LIBRARIES/libverifier_intermediates/import_includes [ 82% 30026/36285] target thumb C++: libverifier &lt;= bootable/recovery/asn1_decoder.cpp [ 82% 30027/36285] target thumb C++: libverifier &lt;= bootable/recovery/verifier.cpp [ 82% 30028/36285] Export includes file: -- out/target/product/shamu/obj/STATIC_LIBRARIES/libverifier_intermediates/export_includes [ 82% 30029/36285] target thumb C++: libverifier &lt;= bootable/recovery/ui.cpp ninja: fatal: fork: Cannot allocate memory make: *** [ninja_wrapper] Error 1 第3种错误：FAILED: /bin/bash out/target/common/obj/JAVA_LIBRARIES/core-all_intermediates/with-local/classes.dex.rsp Out of memory error (version 1.2-rc4 &#39;Carnac&#39; (298900 f95d7bdecfceb327f9d201a1348397ed8a843843 by android-jack-team@google.com)). GC overhead limit exceeded. Try increasing heap size with java option &#39;-Xmx&lt;size&gt;&#39;. Warning: This may have produced partial or corrupted output. [ 31% 11494/36285] host C++: libartd-compiler &lt;= art/compiler/optimizing/graph_visualizer.cc [ 31% 11494/36285] Building with Jack: out/target/common/obj/JAVA_LIBRARIES/libprotobuf-java-nano_intermediates/classes.jack [ 31% 11494/36285] build out/target/common/obj/JAVA_LIBRARIES/sdk_v21_intermediates/classes.jack ninja: build stopped: subcommand failed. 第4种错误：[ 6% 2375/35393] target Java: icu4j (out/target/common/obj/JAVA_LIBRARIES/icu4j_intermediates/classes) Note: Some input files use or override a deprecated API. Note: Recompile with -Xlint:deprecation for details. Note: external/icu/icu4j/main/classes/core/src/com/ibm/icu/impl/Relation.java uses unchecked or unsafe operations. Note: Recompile with -Xlint:unchecked for details. [ 6% 2394/35393] host C++: libLLVMMC_32 &lt;= external/llvm/lib/MC/MCDwarf.cppninja: fatal: fork: Cannot allocate memory make: *** [ninja_wrapper] Error 1 第5种错误：123456789101112[ 5% 1883/35393] Docs droiddoc: out/target/common/docs/api-stubsFAILED: /bin/bash out/target/common/docs/api-stubs-timestamp.rspOpenJDK 64-Bit Server VM warning: INFO: os::commit_memory(0x00000000bdb80000, 72876032, 0) failed; error=&apos;Cannot allocate memory&apos; (errno=12)## There is insufficient memory for the Java Runtime Environment to continue.# Native memory allocation (mmap) failed to map 72876032 bytes for committing reserved memory.# An error report file with more information is saved as:# /home/michaelx/AOSP_NBD91Z/hs_err_pid508.log[ 5% 1883/35393] Docs droiddoc: out/target/common/docs/system-api-stubsDroidDoc took 27 sec. to write docs to out/target/common/docs/system-api-stubsninja: build stopped: subcommand failed.make: *** [ninja_wrapper] Error 1 解决内存不足的3个办法： 增加机器内存 增加swap分区 修改prebuild/sdk/tools/jack-admin文件 第一种方式就不说了，给机器加根内存条，壕专享。第二种方式：增加swap分区：http://hancj.blog.51cto.com/89070/197915第三种方式：12345678910# 备份jack-admin$ cp prebuild/sdk/tools/jack-admin ~/Docments/jack-admin.original# 修改jack-admin文件$ vim prebuild/sdk/tools/jack-admin# start-server方法，笔者的jack-admin在443行，修改该方法中的一句话：# JACK_SERVER_COMMAND=&quot;java -Djava.io.tmpdir=$TMPDIR $JACK_SERVER_VM_ARGUMENTS -cp $LAUNCHER_JAR $LAUNCHER_NAME&quot;# 改成下面这行,增加java堆大小。JACK_SERVER_COMMAND=&quot;java -Djava.io.tmpdir=$TMPDIR $JACK_SERVER_VM_ARGUMENTS -Xmx8000M -cp $LAUNCHER_JAR $LAUNCHER_NAME&quot; 以上增加的-Xmx8000M，表示允许java在运行时java堆使用最大不超过8000M内存，这个数值是笔者经历了多次测试得到的结果，2048M，4096M，依旧没通过编译，改成8000M后编译通过，可能跟笔者自身硬件限制有很大关系 另一种修改方式：修改jack-admin第29行的变量：JACK_SERVER_VM_ARGUMENTS=&quot;${JACK_SERVER_VM_ARGUMENTS:=-Dfile.encoding-UTF-8 -XX:+TieredCompilation}&quot; 改成： JACK_SERVER_VM_ARGUMENTS=&quot;${JACK_SERVER_VM_ARGUMENTS:=-Dfile.encoding-UTF-8 -XX:+TieredCompilation -Xmx8000M}&quot; 但是这种修改方式仍然不好使，编译失败了。 笔者是尝试了第二，三种方式解决。 jack-server无法运行错误日志如下：[ 37% 13421/35393] Ensure Jack server is installed and started FAILED: /bin/bash -c &quot;(prebuilts/sdk/tools/jack-admin install-server prebuilts/sdk/tools/jack-launcher.jar prebuilts/sdk/tools/jack-server-4.8.ALPHA.jar 2&gt;&amp;1 || (exit 0) ) &amp;&amp; (JACK_SERVER_VM_ARGUMENTS=\\&quot;-Dfile.encoding=UTF-8 -XX:+TieredCompilation\\&quot; prebuilts/sdk/tools/jack-admin start-server 2&gt;&amp;1 || exit 0 ) &amp;&amp; (prebuilts/sdk/tools/jack-admin update server prebuilts/sdk/tools/jack-server-4.8.ALPHA.jar 4.8.ALPHA 2&gt;&amp;1 || exit 0 ) &amp;&amp; (prebuilts/sdk/tools/jack-admin update jack prebuilts/sdk/tools/jacks/jack-2.28.RELEASE.jar 2.28.RELEASE || exit 47; prebuilts/sdk/tools/jack-admin update jack prebuilts/sdk/tools/jacks/jack-3.36.CANDIDATE.jar 3.36.CANDIDATE || exit 47; prebuilts/sdk/tools/jack-admin update jack prebuilts/sdk/tools/jacks/jack-4.7.BETA.jar 4.7.BETA || exit 47 )&quot; Jack server already installed in &quot;/home/michaelx/.jack-server&quot; Launching Jack server java -XX:MaxJavaStackTraceDepth=0 -Djava.io.tmpdir=/tmp -Dfile.encoding=UTF-8 -XX:+TieredCompilation -cp /home/michaelx/.jack-server/launcher.jar com.android.jack.launcher.ServerLauncher Jack server failed to (re)start, try &#39;jack-diagnose&#39; or see Jack server log No Jack server running. Try &#39;jack-admin start-server&#39; No Jack server running. Try &#39;jack-admin start-server&#39; [ 37% 13421/35393] target thumb C++: libicui18n &lt;= external/icu/icu4c/source/i18n/coptccal.cpp [ 37% 13421/35393] target thumb C++: libicui18n &lt;= external/icu/icu4c/source/i18n/compactdecimalformat.cpp [ 37% 13421/35393] target thumb C++: libicui18n &lt;= external/icu/icu4c/source/i18n/cpdtrans.cpp ninja: build stopped: subcommand failed. 解决Jack server failed to (re)start办法： 1234$ cd /prebuild/sdk/tools/$ jack-admin stop-server$ jack-admin start-server 和各路编译错误大战了7天7夜（真的是7天7夜呀，碰到的无数问题我都没写完呢），终于修成正果。 总结到了这里，相信大家都能轻松搞机了，如果有需要Nexus的刷机教程，请留言评论，下次出一篇Nexus的刷机过程。放2张Nexus 6刷机后的高清截图 首屏截图 抽屉截图 本文原创作者:MichaelX,博客地址:http://blog.csdn.net/xiong_it.转载请注明来源 欢迎光临：MichaelX’s Blog 参考链接感谢AOSP官网：https://source.android.com/source/initializing.htmlAskUbuntu：http://askubuntu.com/questions/709904/ubuntu-openjdk-8-unable-to-locate-packageCSDN:http://blog.csdn.net/brightming/article/details/49763515 etc….","categories":[{"name":"Android","slug":"Android","permalink":"https://xiong-it.github.io/categories/Android/"}],"tags":[{"name":"Ubuntu","slug":"Ubuntu","permalink":"https://xiong-it.github.io/tags/Ubuntu/"},{"name":"AOSP","slug":"AOSP","permalink":"https://xiong-it.github.io/tags/AOSP/"},{"name":"Nexus","slug":"Nexus","permalink":"https://xiong-it.github.io/tags/Nexus/"},{"name":"Pixel","slug":"Pixel","permalink":"https://xiong-it.github.io/tags/Pixel/"}]},{"title":"Android:BLE智能硬件开发详解","slug":"Android-BLE智能硬件开发详解","date":"2017-03-14T03:23:18.000Z","updated":"2017-05-03T08:21:21.752Z","comments":true,"path":"2017/03/14/Android-BLE智能硬件开发详解/","link":"","permalink":"https://xiong-it.github.io/2017/03/14/Android-BLE智能硬件开发详解/","excerpt":"前些年，智能硬件炒的挺火的，那今天，咱就来说说智能硬件那些事","text":"前些年，智能硬件炒的挺火的，那今天，咱就来说说智能硬件那些事 目录 前言 BLE是个什么鬼 BLE中的角色分工 主要的关键词和概念 GATT(Generic Attribute Profile ) Characteristic Service Android如何使用BLE 蓝牙权限 APP和BLE外设交互流程 后记 本文作者MichaelX，博客地址：http://blog.csdn.net/xiong_it 转载请注明来源 前言前些年，智能硬件炒的挺火的，那今天，咱就来说说智能硬件那些事。BLE是智能硬件的一种通讯方式，通过BLE连接，iOS &amp; Android手机和智能硬件就可以进行自定义的交互了。交互的体验如何，很大程度上取决于智能硬件的驱动工程师驱动写的好不好，以及App的代码质量如何。 笔者曾参与过多款BLE智能硬件的开发，许久不用，怕忘了，把自己的整理的一些知识记录与此，同时也希望能够给一些同学带来帮助。本文将尽力向读者讲清楚BLE是什么，以及在实际Android开发中该如何使用BLE。 前方高能：文章有点长，笔者经历了好几次改版，也花费了好几个月的业余时间，读者可能需要点耐心。着急的读者可直接跳转至Android如何使用BLE BLE是个什么鬼BLE：Bluetooth Low Energy,低功耗蓝牙。Android官方介绍如下： Android 4.3 (API Level 18) introduces built-in platform support for Bluetooth Low Energy in the central role and provides APIs that apps can use to discover devices, query for services, and read/write characteristics. In contrast to Classic Bluetooth, Bluetooth Low Energy (BLE) is designed to provide significantly lower power consumption. This allows Android apps to communicate with BLE devices that have low power requirements, such as proximity sensors, heart rate monitors, fitness devices, and so on. 什么意思呢？自从API18/Android4.3开始，Android开始支持低功耗蓝牙并给APP提供了一套api调用。相比传统蓝牙来说，BLE技术旨在降低蓝牙功耗。至于我们Android开发者来说，要做的就是调用这套api，和具备蓝牙的智能硬件沟通，通过蓝牙读写操控智能硬件。 BLE技术允许APP和那些有着低功耗需求的BLE设备进行通讯，这些设备包括但不限于：距离传感器设备，心跳率检测仪，健身器材，智能穿戴等。 约定:文中提到的”外设”,”BLE外设”和”智能硬件”是等价的.请读者知悉. 角色分工 Once the phone and the activity tracker have established a connection, they start transferring GATT metadata to one another. Depending on the kind of data they transfer, one or the other might act as the server. For example, if the activity tracker wants to report sensor data to the phone, it might make sense for the activity tracker to act as the server. If the activity tracker wants to receive updates from the phone, then it might make sense for the phone to act as the server. 在Android APP和BLE外设进行交互时,他们分别扮演两个角色.这两个角色是不固定的.GATT server:发送数据的一方.GATT client:接收数据的一方.当APP向外设写入数据时,APP就是server,外设就是client;当APP读取外设数据时,APP就是client.外设就是server. 主要的关键词和概念GATT(Generic Attribute Profile ) The GATT profile is a general specification for sending and receiving short pieces of data known as “attributes” over a BLE link. All current Low Energy APPlication profiles are based on GATT. 这个是BLE通讯的基本协议,这个协议定义了BLE发送和接收一小段数据的规范,这些被传输的小段数据被称为”attributes”. Characteristic A characteristic contains a single value and 0-n descriptors that describe the characteristic’s value. A characteristic can be thought of as a type, analogous to a class. 博主的理解中,”Characteristic”是BLE通讯之间的沟通”搬运工”,因为这是我们从智能硬件直接读写的东西,它依附于下文的Service存在，有自己的标志码：uuid。它『分为读取BLE外设数据的Characteristic &amp; 向BLE外设写入数据的Characteristic』。下面章节中将用代码说话. Service A service is a collection of characteristics. For example, you could have a service called “Heart Rate Monitor” that includes characteristics such as “heart rate measurement.” 此Service非彼Android四大组件中的彼Service,而是BluetoothGattService.这个Service是一个characteristics的集合,它可以理解为针对某个信号的通讯线路。 Android如何使用BLE蓝牙权限使用BLE需要两个权限 12&lt;uses-permission android:name=\"android.permission.BLUETOOTH\"/&gt;&lt;uses-permission android:name=\"android.permission.BLUETOOTH_ADMIN\"/&gt; 如果你想要APP只适配具备BLE的手机,那个可以再添加一个硬件权限特性1&lt;uses-feature android:name=\"android.hardware.bluetooth_le\" android:required=\"true\"/&gt; APP和BLE外设交互流程APP和BLE外设交互的一个大概流程就是: BLE外设打开电源 APP初始化蓝牙 APP扫描周边BLE外设 APP连接到周边BLE外设 APP读写BLE外设 交互完成,APP向BLE外设写入关机/待机指令(可选) BLE外设关机 APP关闭本地蓝牙连接 以下将逐步利用代码进行讲解APP和BLE外设交互. 初始化BLEJava代码判断当前手机是否支持BLE低功耗蓝牙12345// 判断手机是否支持BLEif (!getPackageManager().hasSystemFeature(PackageManager.FEATURE_BLUETOOTH_LE)) &#123; Toast.makeText(this, R.string.ble_not_supported, Toast.LENGTH_SHORT).show(); finish();// 如果手机不支持BLE就关闭程序,仅供参考&#125; 初始化蓝牙管理者和适配器,这2个对象是ble通讯的基石.123456// 初始化蓝牙管理者和适配器,这2个对象是ble通讯的基石.private BluetoothAdapter mBluetoothAdapter;...final BluetoothManager bluetoothManager = (BluetoothManager) getSystemService(Context.BLUETOOTH_SERVICE);mBluetoothAdapter = bluetoothManager.getAdapter(); 跳转到系统蓝牙设置界面1234567private BluetoothAdapter mBluetoothAdapter;...// 验证蓝牙是否已打开,如果没打开就提示用户跳转打开.if (mBluetoothAdapter == null || !mBluetoothAdapter.isEnabled()) &#123; Intent enableBtIntent = new Intent(BluetoothAdapter.ACTION_REQUEST_ENABLE); startActivityForResult(enableBtIntent, REQUEST_ENABLE_BT); &#125; APP扫描周边BLE外设需要实现一个BluetoothAdapter.LeScanCallback回调接口，得到扫描结果。该接口只有一个回调方法：123456/** * @param device 被手机蓝牙扫描到的BLE外设实体对象 * @param rssi 大概就是表示BLE外设的信号强度，如果为0，则表示BLE外设不可连接。 * @param scanRecord 被扫描到的BLE外围设备提供的扫描记录，一般没什么用 */public void onLeScan(final BluetoothDevice device, int rssi, byte[] scanRecord) 由于扫描BLE设备比较消耗资源，官方推荐间歇性扫描，示例代码如下1234567891011121314151617181920212223242526272829303132333435363738394041424344454647 private BluetoothAdapter mBluetoothAdapter; private boolean mScanning; private Handler mHandler; // 每扫描10s休息一下 private static final long SCAN_PERIOD = 10000; private BluetoothAdapter.LeScanCallback mLeScanCallback = new BluetoothAdapter.LeScanCallback() &#123; @Override public void onLeScan(final BluetoothDevice device, int rssi, byte[] scanRecord) &#123; // TODO 这里可以进行连接操作，连接操作见下一小节 if (device != null &amp;&amp; device.getName() != null &amp;&amp; device.getName().contain(&quot;你的产品名称&quot;))&#123; // 连接设备 connectDevice(device); // 停止扫描 scanLeDevice(false); &#125; &#125; &#125;); &#125;&#125;; ... /** * @param enable 是否进行扫描，false则停止扫描 */ private void scanLeDevice(final boolean enable) &#123; if (enable) &#123; // 利用Handler进行间歇性扫描，每次扫描时间：10s mHandler.postDelayed(new Runnable() &#123; @Override public void run() &#123; mScanning = false; mBluetoothAdapter.stopLeScan(mLeScanCallback); &#125; &#125;, SCAN_PERIOD); mScanning = true; mBluetoothAdapter.startLeScan(mLeScanCallback); &#125; else &#123; // 停止扫描 mScanning = false; mBluetoothAdapter.stopLeScan(mLeScanCallback); &#125; ... &#125; APP连接周边BLE外设连接操作是进行手机和BLE外设交互的基础，请看下面connectDevice(BluetoothDevice)方法实现。 分两步走： 判断该设备是否连接过，连接过则首先尝试直接连接：BluetoothGatt.connect() 首次连接或者直连失败使用：BluetoothDevice.connectGatt(Context context, boolean autoConnect, BluetoothGattCallback callback)123456789101112131415161718192021222324252627282930313233343536public boolean connectDevice(final BluetoothDevice device) &#123; if (mBluetoothAdapter == null || device == null) &#123; Log.w(TAG, \"BluetoothAdapter not initialized or unspecified address.\"); return false; &#125; String address = device.getAddress(); // 之前连接过的设备，尝试直接连接。mBluetoothDeviceAddress表示刚才连接过的设备地址 if (mBluetoothDeviceAddress != null &amp;&amp; address.equals(mBluetoothDeviceAddress) &amp;&amp; mBluetoothGatt != null) &#123; Log.d(TAG, \"Trying to use an existing mBluetoothGatt for connection.\"); if (mBluetoothGatt.connect()) &#123;// 连接成功 // 修改连接状态变量 mConnectionState = STATE_CONNECTING; return true; &#125; else &#123; return false; &#125; &#125; final BluetoothDevice remoteDevice = mBluetoothAdapter.getRemoteDevice(address); if (remoteDevice == null) &#123; Log.w(TAG, \"Device not found. Unable to connect.\"); return false; &#125; mBluetoothGatt = remoteDevice.connectGatt(context, false, mGattCallback); Log.d(TAG, \"Trying to create a new connection.\"); // 将当前连接上的设备地址赋值给连接过的设备地址变量 mBluetoothDeviceAddress = address; // 改变连接状态变量 mConnectionState = STATE_CONNECTING; return true; &#125; 连接BEL外设时，需要一个实现回调接口以得到连接状态，BluetoothGattCallback大概实现如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657private final BluetoothGattCallback mGattCallback = new BluetoothGattCallback() &#123; @Override public void onConnectionStateChange(BluetoothGatt gatt, int status, int newState) &#123; // 该方法在连接状态改变时回调，newState即代表当前连接状态 String intentAction; // 连接上了 if (newState == BluetoothProfile.STATE_CONNECTED) &#123; intentAction = ACTION_GATT_CONNECTED; // 改变蓝牙连接状态变量 mConnectionState = STATE_CONNECTED; // 发送自定义广播：连接上了 broadcastUpdate(intentAction); // 当前外设相当于前面章节提到的Server角色：提供数据被手机读取 Log.i(TAG, &quot;Connected to GATT server.&quot;); // 获取读/写服务：Service。该方法会触发下面的onServicesDiscovered()回调 mBluetoothGatt.discoverServices(); &#125; else if (newState == BluetoothProfile.STATE_DISCONNECTED) &#123;// 断开连接了 intentAction = ACTION_GATT_DISCONNECTED; mConnectionState = STATE_DISCONNECTED; Log.i(TAG, &quot;Disconnected from GATT server.&quot;); // 发送自定义广播：断开了连接 broadcastUpdate(intentAction); &#125; &#125; @Override // 该方法在蓝牙服务被发现时回调。由上述的mBluetoothGatt.discoverServices()触发结果。 public void onServicesDiscovered(BluetoothGatt gatt, int status) &#123; // 发现服务。status表示发现服务的结果码 if (status == BluetoothGatt.GATT_SUCCESS) &#123; broadcastUpdate(ACTION_GATT_SERVICES_DISCOVERED); // TODO 从发现的Service来找出读数据用的BluetoothGattCharacteristic和写数据用的BluetoothGattCharacteristic。 initReadAndWriteCharacteristic(gatt.getServices()); &#125; else &#123;// 未发现服务 Log.w(TAG, &quot;onServicesDiscovered received: &quot; + status); &#125; &#125; @Override // 读取操作的回调结果 public void onCharacteristicRead(BluetoothGatt gatt, BluetoothGattCharacteristic characteristic, int status) &#123; if (status == BluetoothGatt.GATT_SUCCESS) &#123; broadcastUpdate(ACTION_DATA_AVAILABLE, characteristic); &#125; &#125; @Override // 写入操作的回调结果 public void onCharacteristicWrite(BluetoothGatt gatt, BluetoothGattCharacteristic characteristic, int status) &#123; &#125;; ... &#125;;... 找出读写”数据包”的”搬运工” 下面是找出读写”搬运工”BluetoothGattCharacteristic的initReadAndWriteCharacteristic()代码实现 1234567891011121314151617181920212223BluetoothGattCharacteristic mReadCharacteristic;BluetoothGattCharacteristic mWriteCharacteristic;public void initReadAndWriteCharacteristic( List&lt;BluetoothGattService&gt; gattServices) &#123; if (gattServices == null) return; // 遍历所有的 GATT Services. for (BluetoothGattService gattService : gattServices) &#123; if (!gattService.getUuid().toString().trim().equalsIgnoreCase(&quot;这里是你期望的Service的uuid，由你司智能外色的驱动工程师决定&quot;)) continue; List&lt;BluetoothGattCharacteristic&gt; gattCharacteristics = gattService.getCharacteristics(); // 遍历当前Service中所有的Characteristics. for (BluetoothGattCharacteristic gattCharacteristic : gattCharacteristics) &#123; if (gattCharacteristic.getUuid().toString().trim().equalsIgnoreCase(&quot;&quot;这里是你期望的写数据的uuid，由你司驱动工程师决定&quot;&quot;)) &#123; mWriteCharacteristic = gattCharacteristic; &#125; else if (gattCharacteristic.getUuid().toString().trim().equalsIgnoreCase(&quot;这里是你期望的读数据的uuid，由你司驱动工程师决定&quot;)) &#123; mReadCharacteristic = gattCharacteristic; &#125; &#125; &#125; &#125; 至此，我们就拿到了可携带读写数据的“搬运工”-『mReadCharacteristic &amp; mWriteCharacteristic』，下面就可以和智能硬件进行交互了。 APP读取BLE外设蓝牙数据想要读取BLE外设的数据时，比如：心跳速率，电量等等。可通过下面方式。123456789101112131415// 告诉”搬运工“我想知道BLE外设当前数据,将回调BluetoothGattCallback接口的onCharacteristicRead()方法mBluetoothGatt.readCharacteristic(mReadCharacteristic);// 读取BLE蓝牙数据操作的回调方法 @Overridepublic void onCharacteristicRead(BluetoothGatt gatt, BluetoothGattCharacteristic characteristic, int status) &#123; if (status == BluetoothGatt.GATT_SUCCESS) &#123; broadcastUpdate(ACTION_DATA_AVAILABLE, characteristic); // ”搬运工“把”数据包“搬出来了 byte[] data = characteristic.getValue(); // 根据驱动工程师给的协议文档，解析该数组，该处假设数组0位上表示心跳速率 int heartRateR = data[0];// 得到心跳速率，做相应UI更新和操作 &#125; &#125; &#125; APP向BLE外设写入数据比如说你想告诉BLE外设让他锁屏，或者进行某个动作，APP向操纵BLE外设时可通过以下方式123456789101112131415// 根据驱动工程师给的协议文档，组织一个数组命令byte[] data = getData();// 将该条命令“数据包”给“搬运工&quot;mWriteCharacteristic.setValue(data);// ”搬运工“将数据搬到BLE外设里面了，将回调BluetoothGattCallback接口的onCharacteristicWrite()方法mBluetoothGatt.writeCharacteristic(characteristic);// 向BLE蓝牙外设写入数据操作的回调方法@Overridepublic void onCharacteristicWrite(BluetoothGatt gatt, BluetoothGattCharacteristic characteristic, int status) &#123; if(status == BluetoothGatt.GATT_SUCCESS) &#123; // 命令写入成功，数据包成功写入BLE外设中 &#125; &#125;; 多说一句，其实，手机关闭外设也是一条写入命令，外设得到该命令后即进入省电待机状态，一般外设也可以通过开/关机键彻底关机。 APP关闭蓝牙连接交互完了，不需要了，还是把APP蓝牙连接给断掉吧1234567public void close() &#123; if (mBluetoothGatt == null) &#123; return; &#125; mBluetoothGatt.close(); mBluetoothGatt = null;&#125; 后记Android官方在SDK中提供了许多demo供开发者参考（1年前左右），其实关于BLE api调用也是有的,不过只涉及了蓝牙外设的连接,未涉及蓝牙数据读写.BLE官方demo路径:User/AndroidSDK/samples/android-19/connectivity/BluetoothLeGatt以上路径是笔者举例的路径,如果你的SDK目录下没有samples目录，现在（20170308）SDK Manager已经不开放sample下载了,请点击下载：android-sample-api19 文件提取密码: y87g 本文原创作者:MichaelX,博客地址:http://blog.csdn.net/xiong_it.转载请注明来源 欢迎光临：MichaelX’s Blog 参考链接https://developer.android.com/guide/topics/connectivity/bluetooth-le.html#terms","categories":[{"name":"Android","slug":"Android","permalink":"https://xiong-it.github.io/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://xiong-it.github.io/tags/Android/"},{"name":"BLE","slug":"BLE","permalink":"https://xiong-it.github.io/tags/BLE/"},{"name":"智能硬件","slug":"智能硬件","permalink":"https://xiong-it.github.io/tags/智能硬件/"}]},{"title":"Design Patterns in Android：模板方法模式","slug":"Design-Patterns-in-Android：模板方法模式","date":"2017-02-10T17:16:27.000Z","updated":"2017-05-03T08:21:21.752Z","comments":true,"path":"2017/02/11/Design-Patterns-in-Android：模板方法模式/","link":"","permalink":"https://xiong-it.github.io/2017/02/11/Design-Patterns-in-Android：模板方法模式/","excerpt":"今天给大家分享的是《设计模式Android篇：模板方法模式》。其实有一定开发经验的小伙伴已经不自觉的使用了模板方法了，今天将通过Android源码和Android开发案例跟大家讲解什么是模板方法模式。","text":"今天给大家分享的是《设计模式Android篇：模板方法模式》。其实有一定开发经验的小伙伴已经不自觉的使用了模板方法了，今天将通过Android源码和Android开发案例跟大家讲解什么是模板方法模式。 前言今天给大家分享的是《设计模式Android篇：模板方法模式》。其实有一定开发经验的小伙伴已经不自觉的使用了模板方法了，今天将通过Android源码和Android开发案例跟大家讲解什么是模板方法模式。点击此处查看《Design Patterns in Android》系列其他文章。 本文原创作者MichaelX（xiong_it），博客链接：http://blog.csdn.net/xiong_it，转载请注明出处。 模板方式模式定义 模板方法模式(Template method pattern):定义一个操作中的算法框架，而将一些步骤延迟到子类中实现，使得子类可以不改变算法结构即可重新定义该算法的某些特定步骤 以上定义有两个关键词 算法框架：其本质是一个方法，也就是模板方法，它的调用会依次执行一些特定的步骤 特定步骤：其本质一系列抽象的方法，交由子类实现，以重新定义该算法细节 模板方法的UML类图 模板方法的UML类图 templateMethod：模板方法methodA,methodB：特定步骤 模板方法示例代码基类123456789101112public abstract class AbstractClass &#123; public void templateMethod() &#123; methodA(); methodB(); &#125; protected void abstract methodA(); protected void abstract methodB();&#125; 子类1234567891011121314151617181920212223242526272829public class ConcreteClassA extends AbstractClass &#123; @Override protected void abstract methodA() &#123; System.out.println(&quot;ConcreteClassA.do something.&quot;); &#125; @Override protected void abstract methodB() &#123; System.out.println(&quot;ConcreteClassA.do other thing.&quot;); &#125;&#125;public class ConcreteClassB extends AbstractClass &#123; @Override protected void abstract methodA() &#123; System.out.println(&quot;ConcreteClassB.do something.&quot;); &#125; @Override protected void abstract methodB() &#123; System.out.println(&quot;ConcreteClassB.do other thing.&quot;); &#125;&#125; Android源码中模板方法模式在Android的api源码中，给我们提供了一个执行异步任务的类AsyncTask，其用法d大致如下 写一个自己的异步任务类（比如叫DownloadTask）继承自AsyncTask，主要复写onPreExecute(),doInBackground(),onPostExecute()等。 执行downloadTask 代码如下 1new DownloadTask().execute(url); 我们发现只要调用了execute（Params…）后，AsyncTask自动调用了各个回调方法了，onPreExecute(),doInBackground(),onPostExecute()等，其实这就是模板方法模式！下面我们通过一个android开发案例来弄懂模板方法。 Android开发中的模板方式模式实践Activity作为四大组件之首，是我们经常要使用到的，除非你的app不用和用户进行UI交互。那在多个Activity中，我们通常在onCreate()做一些程序化的事情 初始化控件 获取网络/数据库数据 注册事件监听 注册广播 等等 在onDestroy()中 反注册广播 资源释放等 这时我们通常可以使用模板方法模式来抽象出一个BaseActityBaseFragment类似，不展开分析。实例代码如下 先写一个基类BaseActity1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556public abstract class BaseActivity extends Activity &#123; @Override public void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); initView(); initData(); initEvent(); registerBroadcast(); &#125; /** * 初始化视图控件 */ protected abstract void initView(); /** * 初始化数据 */ protected abstract void initData(); /** * 初始化点击长按等事件 */ protected abstract void initEvent(); /** * 注册广播接收者 */ protected void registerBroadcast() &#123; // 子类可以选择性复写 &#125; @Override public void onDestroy() &#123; super.onDestroy(); unRegisterBroadcast(); releaseMemory(); &#125; /** * 注销广播接收者 */ protected void unRegisterBroadcast() &#123; // 子类可以选择性复写 &#125; /** * 做些释放对象引用等其他操作以释放内存 */ protected abstract void releaseMemory();&#125; 随手写一个实现类MyActivity 123456789101112131415161718192021222324public class MyActivity extends BaseActivity &#123; @Override protected void initView() &#123; setContentView(resId); // TODO findViewById(); &#125; @Override protected void initData() &#123; // TODO 访问数据库/网络获取数据 &#125; @Override protected void initEvent() &#123; // TODO setOnClickListener &#125; @Override protected void releaseMemory() &#123; // TODO 把一些手动释放的对象值设为null someObj = null;// and so on. &#125;&#125; 如果再有一个其他Activity代码也是如此编写，以BaseActivity的onCreate(),onDestroy()为模板方法（算法框架），initView(),initData(),initEvent()等方法为特定步骤，利用模板方法构建了一个较好的基类，子类无需修改BaseActivity的算法框架，不同的Activity只需复写这些特定步骤即重新定义这些特定的细节步骤。 总结看完这篇《Design Patterns in Android：策略模式》，是不是很多人恍然大悟，原来模板方法就是这样啊！当编写一个方法时，其中包含了某些特定的步骤时，就可以考虑使用模板方法模式了。 好了，今天的《设计模式Android篇：策略模式》就到这里，请继续关注《Design Patterns in Android》（设计模式Android篇）系列博文，欢迎各位读者朋友评论区拍砖交流，共同进步。","categories":[{"name":"Design Pattern","slug":"Design-Pattern","permalink":"https://xiong-it.github.io/categories/Design-Pattern/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://xiong-it.github.io/tags/设计模式/"},{"name":"Design Pattern","slug":"Design-Pattern","permalink":"https://xiong-it.github.io/tags/Design-Pattern/"},{"name":"Android","slug":"Android","permalink":"https://xiong-it.github.io/tags/Android/"},{"name":"模板方法模式","slug":"模板方法模式","permalink":"https://xiong-it.github.io/tags/模板方法模式/"},{"name":"Template Method","slug":"Template-Method","permalink":"https://xiong-it.github.io/tags/Template-Method/"}]},{"title":"Design Patterns in Android：策略模式","slug":"Design-Patterns-in-Android：策略模式","date":"2017-02-07T03:39:33.000Z","updated":"2017-05-03T08:21:21.752Z","comments":true,"path":"2017/02/07/Design-Patterns-in-Android：策略模式/","link":"","permalink":"https://xiong-it.github.io/2017/02/07/Design-Patterns-in-Android：策略模式/","excerpt":"刚过去的春节，大家有没有从“节后综合征”中痊愈满血呢？ 新年里给大家带来的第一篇是《设计模式Android篇：策略模式》。 本文将通俗易懂的给大家分享Android源码中的策略模式和如何在开发中实践策略模式。","text":"刚过去的春节，大家有没有从“节后综合征”中痊愈满血呢？ 新年里给大家带来的第一篇是《设计模式Android篇：策略模式》。 本文将通俗易懂的给大家分享Android源码中的策略模式和如何在开发中实践策略模式。 前言刚过去的春节，大家有没有从“节后综合征”中痊愈满血呢？新年里给大家带来的第一篇是《设计模式Android篇：策略模式》。点击此处查看《Design Patterns in Android》系列其他文章。 本文原创作者MichaelX（xiong_it），博客链接：http://blog.csdn.net/xiong_it，转载请注明出处。 策略模式定义 策略模式(Strategy pattern)：定义一组算法，将其各个封装，并且使他们有交换性。 策略模式好处在于使得算法在用户使用的时候能独立的改变，单一的修改，并且有良好扩展性。 算法：指的是各个策略的实现逻辑，而非算法领域的数据算法。 策略模式UML类图 策略模式UML类图 策略模式各角色讲解 IStrategy：策略基类（接口或者抽象类），定义子策略需要实现的方法，比如excute()，该方法取决于客户端代码（高层代码）需要该策略实现什么功能，子类则实现该方法，封装自己的算法，供外部调用。 Context：此Context，非彼（Android中的）Context，它持有IStrategy真实的实例对象，提供给客户端调用IStrategy时的上下文调度者。 ConcreteStrategyA：实现父类IStrategy的方法，封装自身算法逻辑。 ConcreteStrategyB：同上 策略模式的示例代码IStrategy123public interface IStrategy &#123; void excute();&#125; ConcreteStrategyA12345public class ConcreteStrategyA implements IStrategy&#123; public void excute() &#123; System.out.println(\"1.我是ConcreteStrategyA的算法实现\"); &#125;&#125; ConcreteStrategyB 12345public class ConcreteStrategyB implements IStrategy&#123; public void excute() &#123; System.out.println(\"2.我是ConcreteStrategyB的算法实现\"); &#125;&#125; Context上下文角色1234567891011public class Context &#123; private IStrategy strategy; public Context(Strategy strategy) &#123; this.strategy = strategy; &#125; public void excute() &#123; this.strategy.excute(); &#125;&#125; 好了，下面是就是客户端代码，描述了如何使用策略模式Client 1234567891011public class Client &#123; public static void main(String[] args) &#123; Context context; context = new Context(new ConcreteStrategyA()); context.excute(); // context = new Context(new ConcreteStrategyB()); // context.excute(); &#125;&#125; 如上，客户端需要什么策略就new什么策略，完全取决于客户端需求，而且如果策略A出现问题，修改策略A就是了，和其他地方完全无关，如果现有策略不符合需求，再实现一个ConcreteStrategyA即可。 Android源码中的策略模式大家在使用Animation动画时，可以给Animation对象设置不同的插值器（Interpolator）来实现动画快慢速度动态效果。 比如：LinearInterpolator，线性插值器，实现匀速动画AccelerateDecelerateInterpolator：加速减速插值器，实现开始加速，结尾时减速的动画 BaseInterpolator类：Interpolator的实现类，就是速度插值器策略的基类12345678910111213141516171819/** * An abstract class which is extended by default interpolators. */abstract public class BaseInterpolator implements Interpolator &#123; private int mChangingConfiguration; /** * @hide */ public int getChangingConfiguration() &#123; return mChangingConfiguration; &#125; /** * @hide */ void setChangingConfiguration(int changingConfiguration) &#123; mChangingConfiguration = changingConfiguration; &#125;&#125; Animation：Context上下文角色12345678910111213141516public abstract class Animation implements Cloneable &#123; // ... // 省略无关代码 // ... private Interpolator mInterpolator; /** * Sets the acceleration curve for this animation. Defaults to a linear * interpolation. * * @param i The interpolator which defines the acceleration curve * @attr ref android.R.styleable#Animation_interpolator */ public void setInterpolator(Interpolator i) &#123; mInterpolator = i; &#125;&#125; LinearInterpolator等子类就实现了各自速度快慢的算法逻辑12345678910111213@HasNativeInterpolatorpublic class LinearInterpolator extends BaseInterpolator &#123; public LinearInterpolator() &#123; &#125; public LinearInterpolator(Context context, AttributeSet attrs) &#123; &#125; public float getInterpolation(float input) &#123; return input; &#125;&#125; 现在，我们给一个ImageView添加View动画 12345ImageView view;Animation animation = getResources().getAnimation(R.anim.pop_anim);// 给view的动画设置一个插值器策略animation.setInterpolator(new LinearInterpolator());view.startAnimation(animation); Android开发中的策略模式实践需求，现在你开发的Android app需要实现盈利，PM经过一番规划，想要你接入微信支付，支付宝支付，银联支付等移动端通用支付方式。 这个功能好实现，接入相关支付SDK即可，问题就在如何优雅的实现这个功能呢？ 延伸阅读：《 Android App支付系列（一）：微信支付接入详细指南(附官方支付demo)》《 Android App支付系列（二）：支付宝SDK接入详细指南(附官方支付demo)》 以下是笔者是实现，供各位读者参考。 PayActivity：客户端角色，支付方式选择界面 AbsPayStrategy：作为支付策略基类，定义了一个pay方法 PayContext：上下文角色，用来封装支付AbsPayStrategy对象 WeChatPayStrategy：封装了微信支付算法逻辑 ALiPayStrategy：封装了支付宝支付算法逻辑 BankCardPayStrategy：封装了银行卡支付算法逻辑 支付功能的示意代码AbsPayStrategy的实际实现应该为抽象类，它需要持有Activity对象。12345public interface AbsPayStrategy &#123; // private Activity mActivity; // 本策略主要就是实现支付功能 void pay();&#125; Context上下文角色1234567891011public class PayContext &#123; private AbsPayStrategy mPayStrategy; public PayContext(AbsPayStrategy payStrategy) &#123; mPayStrategy = payStrategy; &#125; public void pay() &#123; mPayStrategy.pay(); &#125;&#125; 微信支付策略实现12345678910/** * 微信支付策略 */public class WeChatPayStrategy implements AbsPayStrategy &#123; public void pay() &#123; // 此处封装微信支付逻辑 // 具体请参考笔者的博文《 Android App支付系列（一）：微信支付接入详细指南(附官方支付demo)》 &#125;&#125; 支付宝支付策略实现 12345678910/** * 支付宝支付策略 */public class ALiPayStrategy implements AbsPayStrategy &#123; public void pay() &#123; // 此处封装支付宝支付逻辑 // 具体请参考笔者的博文《 Android App支付系列（二）：支付宝支付SDk接入详细指南(附官方支付demo)》 &#125;&#125; 具体的客户端代码，此处为PayActivity 123456789101112131415161718192021222324252627public class PayActivity extends Activity implements View.OnclickListener&#123; private PayContext mPayContext; @Override public void onClick(View view) &#123; switch(v.getId()) &#123;// 客户端来决定使用哪种支付策略 case R.id.wechat_pay: mPayContext = new PayContext(new WechatPayStrategy()); break; case R.id.wechat_pay: mPayContext = new PayContext(new ALiPayStrategy()); break; case R.id.wechat_pay: mPayContext = new PayContext(BankCardPayStrategy()); break; default: mPayContext = new PayContext(new WechatPayStrategy()); break; &#125; // 利用实际的支付策略对象进行支付 mPayContext.pay(); &#125; &#125; 这样就实现了一个app内的支付功能，如果微信支付出现问题了，改动微信支付策略代码，支付宝支付出现问题，改动想要实现即可，职责单一。 如果PM有一天说：我们需要接入百付宝，京东支付。怎么办？简单啊，实现相应的支付策略即可，完美适应需求变更，实现功能扩展。 总结如果在开发某功能时，可能出现多种平等的选择，可以考虑使用策略模式实现。 好了，今天的《设计模式Android篇：策略模式》就到这里，请继续关注《Design Patterns in Android》（设计模式Android篇）系列博文，欢迎各位读者朋友评论区拍砖交流，共同进步。","categories":[{"name":"Design Pattern","slug":"Design-Pattern","permalink":"https://xiong-it.github.io/categories/Design-Pattern/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://xiong-it.github.io/tags/设计模式/"},{"name":"Design Pattern","slug":"Design-Pattern","permalink":"https://xiong-it.github.io/tags/Design-Pattern/"},{"name":"Android","slug":"Android","permalink":"https://xiong-it.github.io/tags/Android/"},{"name":"策略模式","slug":"策略模式","permalink":"https://xiong-it.github.io/tags/策略模式/"},{"name":"Strategy","slug":"Strategy","permalink":"https://xiong-it.github.io/tags/Strategy/"}]},{"title":"Design Patterns in Android：单例模式","slug":"Design-Patterns-in-Android：单例模式","date":"2017-01-17T08:11:02.000Z","updated":"2017-05-03T08:21:21.752Z","comments":true,"path":"2017/01/17/Design-Patterns-in-Android：单例模式/","link":"","permalink":"https://xiong-it.github.io/2017/01/17/Design-Patterns-in-Android：单例模式/","excerpt":"这是《Design Patterns in Android》系列第一篇博文，那就从本开始和笔者一起领略Android开发中设计模式的魅力吧。本系列《设计模式Android篇》博文将循序渐进的向读者讲解设计模式在Android开发的实践应用","text":"这是《Design Patterns in Android》系列第一篇博文，那就从本开始和笔者一起领略Android开发中设计模式的魅力吧。本系列《设计模式Android篇》博文将循序渐进的向读者讲解设计模式在Android开发的实践应用 前言这是《Design Patterns in Android》系列第一篇博文，那就从本开始和笔者一起领略Android开发中设计模式的魅力吧。本系列《设计模式Android篇》博文将遵循以下模式，循序渐进的向读者讲解设计模式在Android开发的实践应用： 给出设计模式的定义和使用场景 给出设计模式的UML类图 给出该设计模式的简单Java代码 给出该设计模式在Android源码中的应用分析 给出该设计模式在Android应用开发中的实践 本文原创作者xiong_it，博客链接：http://blog.csdn.net/xiong_it，转载请注明出处。 单例模式定义 单例模式(Singleton pattern):确保一个类只有一个实例，并提供对该实例的全局访问。 根据其定义，它的使用场景：当你需要创建一个对象，但是创建这个对象时需要消耗大量的系统资源，或者这个对象迫于某种原因只能在内存中存在一个实例的时候，单例模式也许是个不错的创建方案。 单例模式UML类图 这里写图片描述 Singleton类作为单例类，它耦合了自身成员变量，并对外提供了一个公开方法getInstance()对instance对象的全局访问。 单例模式代码示例众所周知，单例模式有多个变种，但是最常见的还是“饿汉式”及“懒汉式”2种。本处示例代码以线程安全的饿汉式举例。 1234567891011121314public class Singleton &#123; private static Singleton sInstance = new Singleton(); private Singleton() &#123; super(); &#125; public static Singleton getInstance() &#123; if(sInstance == null) &#123; sInstance = new Singleton(); &#125; return sInstance; &#125;&#125; 单例模式注意事项主要有3点： 如果处于多线程环境，注意保持线程安全，不然就无法保证单例了 单例模式的默认构造方法的修饰符需改为private，只能类内部访问，确保外部不能直接new出该实例 单例模式需要提供一个全局访问入口，这个入口通常以getInstance()的public静态方法形式呈现 Android源码中的单例模式InputMethodManager是用来管理输入法和软键盘状态的关键类，它就是源码中一个单例模式应用的典型案例。 12345678910111213141516171819202122232425262728293031public final classs InputMethodManager &#123; /*... 省略代码，保留关键代码 ...*/ static InputMethodManager sInstance; InputMethodManager(IInputMethodManager service, Looper looper) &#123; mService = service; mMainLooper = looper; mH = new H(looper); mIInputContext = new ControlledInputConnectionWrapper(looper, mDummyInputConnection, this); &#125; /** * Retrieve the global InputMethodManager instance, creating it if it * doesn&apos;t already exist. * @hide */ public static InputMethodManager getInstance() &#123; synchronized (InputMethodManager.class) &#123; if (sInstance == null) &#123; IBinder b = ServiceManager.getService(Context.INPUT_METHOD_SERVICE); IInputMethodManager service = IInputMethodManager.Stub.asInterface(b); sInstance = new InputMethodManager(service, Looper.getMainLooper()); &#125; return sInstance; &#125; &#125;&#125; 从代码中，我们可以看到，InputMethodManager中有一个非公开的静态成员变量sInstance,它的构造方法也是非公开的，但是它对外（framwork层）提供了一个public的静态方法getInstance(Context)来对外提供单例对象，当该对象不存在时，就通过进程间通讯创建一个对象。我们试想一下，假如它不是单例的话，在不同的应用中大家都可以自由创建该对象，该对象又极容易造成内存泄漏，创建N个InputMethodManager实例的话，你的Android手机该卡成什么鬼样子？？ 延伸阅读:《Android InputMethodManager 导致的内存泄露及解决方案》 所以说，InputMethodManager做成单例是一个明智的选择，实际上，除了InputMethodManager，直接操作系统资源的许多??Manager都是采用了单例模式来创建，比如AccessibilityManager，InputManager，LayoutInflater，BulutoothManager等。不过他们的单例模式实现多种多样，其中LayoutInflater及许多其他Manager是采用集合缓存的形式的实现，第一次getSystemService(String)获取LayouInflater对象时，系统会通过ServiceFetcher创建一个对象并缓存到系统服务列表中，第二次获取时，直接从列表中得到该对象，并不再二次创建，确保单例。 Android开发中的单例实践大家用过Universal-Image-Loader吗？没用过也没关系，使用UIL加载一张图片非常简单： 1ImageLoader.getInstance().displayImage(imageUrl, imageView); 很眼熟，对不对？其实，这里ImageLoader对象的创建就是采用了单例模式的实现。假如它不是单例实现呢？每次用都初始化一次吗？每次都创建一个新的对象吗？显然这是很浪费资源的一件事，所以ImageLoader是采用了单例模式来创建一个对象，以后用的时候还是复用那个对象，保证了UIL API的易用性，同时也兼顾了系统资源的合理利用。ImageLoader的单例实现代码是1234567891011121314151617181920212223public class ImageLoader &#123; /* ... 省略代码，保留关键代码 ... */ private volatile static ImageLoader instance; protected ImageLoader() &#123; &#125; /** Returns singleton class instance */ public static ImageLoader getInstance() &#123; if (instance == null) &#123; synchronized (ImageLoader.class) &#123; if (instance == null) &#123; instance = new ImageLoader(); &#125; &#125; &#125; return instance; &#125;&#125; volatile关键字修饰的变量，一次只能有一个线程操作该变量，保证线程安全。 总结当你的某个类多次创建很耗资源，或者你的某个类对象你只希望它存在一个实例对象在内存中时，请考虑单例模式。 好了，今天的《设计模式Android篇：单例模式》就到这里，请继续关注《Design Patterns in Android》（设计模式Android篇）系列博文，欢迎各位读者朋友评论区拍砖交流，共同进步。","categories":[{"name":"Design Pattern","slug":"Design-Pattern","permalink":"https://xiong-it.github.io/categories/Design-Pattern/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://xiong-it.github.io/tags/设计模式/"},{"name":"Design Pattern","slug":"Design-Pattern","permalink":"https://xiong-it.github.io/tags/Design-Pattern/"},{"name":"单例模式","slug":"单例模式","permalink":"https://xiong-it.github.io/tags/单例模式/"},{"name":"Singleton","slug":"Singleton","permalink":"https://xiong-it.github.io/tags/Singleton/"},{"name":"Android","slug":"Android","permalink":"https://xiong-it.github.io/tags/Android/"}]},{"title":"Design Patterns in Android：目录纲要","slug":"Design-Patterns-in-Android：目录纲要","date":"2017-01-17T07:14:34.000Z","updated":"2017-05-03T08:21:21.752Z","comments":true,"path":"2017/01/17/Design-Patterns-in-Android：目录纲要/","link":"","permalink":"https://xiong-it.github.io/2017/01/17/Design-Patterns-in-Android：目录纲要/","excerpt":"","text":"前言继《设计模式系列：OOP设计6大原则》之后，博主自此将“间歇性”更新《Design Patterns in Android》（设计模式Android篇），旨在总结自己作为一名Android开发者，在摸索设计模式的过程中爬过的坑，因为很多设计模式的博文，书籍都是针对Java场景的，为了帮助一些Android开发者更贴切的理解和应用设计模式，博文将描述在Android源码中存在的设计模式，以及Android项目如何实践设计模式，将笔者在Android项目实践这些设计模式的心得体会，所得所想以文字的形式展现在读者朋友的眼前，也希望能够和广大的读者有更多的交流，促使自身进步。 间歇性：1、笔者对于23种设计模式也不是全部了解,并没有全部实践过，只能根据自己一些经验来描述一些实践过或者接触过的模式2、笔者中途也会更新其他博文，与读者分享 本文作者xiong_it，博客链接：http://blog.csdn.net/xiong_it。转载请注明出处。 什么是设计模式在分享设计模式in Android之前，我们先来看下“设计模式”的定义 在软件工程中，设计模式（design pattern）是对软件设计中普遍存在（反复出现）的各种问题，所提出的解决方案。-维基百科《设计模式 (计算机)》 设计模式这个术语是由埃里希·伽玛（Erich Gamma）等人在1990年代从建筑设计领域引入到计算机科学的。并在1994年，埃里希·伽玛（Erich Gamma）, Richard Helm, Ralph Johnson，John Vlissides“四人帮”（Gang of Four，GoF）著成《设计模式：可复用面向对象软件的基础》为人所熟知并开始广泛流传。 也就是说，设计模式是一种软件编写过程中，解决编程问题的一种可复用的，有规矩可遵循的方案。 快速了解常用23中设计模式，《设计模式教你追MM》 23种设计模式分类根据设计模式的使用场景，大概可分为3类： 创建型处理如何创建实例、对象。 单例模式(Singleton pattern) 原型模式(Prototype pattern) 建造者/构造器模式(Builder Pattern) 工厂方法模式(Factory Method pattern) 抽象工厂模式(Abstact Factory) 结构型处理类及对象的复合关系。 适配器模式(Adapter pattern) 桥接模式(Bridge pattern) 组合模式(Composite pattern) 装饰模式(Decorator pattern) 享元模式(Flyweight pattern) 代理模式(Proxy pattern) 行为型 处理类/对象之间的转换，通讯。 策略模式(Strategy pattern) 模板方法模式(Template method pattern) 职责链模式(Chain-of-responsibility pattern) 命令模式(Command pattern) 解释器模式(Interpreter pattern) 迭代器模式(Iterator pattern) 仲裁器/中介者模式(Mediator pattern) 备忘录模式(Memento pattern) 观察者(模式Observer pattern) 状态模式(State pattern) 参观者/访问者模式(Visitor) 结语如上，23种设计模式，各有各的使用场景，应用适当，可以使得代码扩展性大大提高，有利于后期需求变更和功能扩展及代码维护，带有链接的模式表示笔者已有介绍该模式在Android开发中的相关博文。 参考维基百科：《设计模式（计算机）》，《设计模式：可复用面向对象软件的基础》","categories":[{"name":"Design Pattern","slug":"Design-Pattern","permalink":"https://xiong-it.github.io/categories/Design-Pattern/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://xiong-it.github.io/tags/设计模式/"},{"name":"Design Pattern","slug":"Design-Pattern","permalink":"https://xiong-it.github.io/tags/Design-Pattern/"},{"name":"Android","slug":"Android","permalink":"https://xiong-it.github.io/tags/Android/"}]},{"title":"设计模式系列：OOP设计6大原则","slug":"设计模式系列：OOP设计6大原则","date":"2017-01-13T02:39:20.000Z","updated":"2017-05-03T08:21:21.756Z","comments":true,"path":"2017/01/13/设计模式系列：OOP设计6大原则/","link":"","permalink":"https://xiong-it.github.io/2017/01/13/设计模式系列：OOP设计6大原则/","excerpt":"","text":"前言相信有过开发经验的人都有过这种体验：让你接手一个的项目，2种情况。A.这个项目已经被好几个人，甚至好几代程序员开发维护过；B.这个项目等待你的全新开发。不给你设时间期限，你更愿意选择哪一个？我相信99.9%的人都会选择B这种开发模式。有木有？？Why？因为不想改一个bug引起n个bug。说到底，就是因为已有的项目架构没有做好，或者没有适时的做架构调整，假如你接手的是旧代码，可能为了添加一个功能，因为架构不具备扩展性，你也许只能在原有的基础上修改几行代码，甚至修改几百上千行代码来达到目的，以此来埋下诸多隐患待下一个接盘侠搞定。那么就引出了今天的话题？什么样的代码才具备可扩展性呢？ 本文作者xiong_it，博客链接：http://blog.csdn.net/xiong_it。转载请注明出处。 Open Close Principle OCP原则（开闭原则）：一个软件实体如类、模块和函数应该对扩展开放，对修改关闭。 wtf???太抽象了！！！在笔者的理解中，OCP是6大原则的最高纲领，所以才如此抽象，晦涩难懂。用面向对象的语言来讲，OCP是一个最抽象的接口，而其余的5大原则只是OCP的子类接口，他们一起定义了OOP世界的开发标准，常用的23中设计模式更是只能算作这6大原则的实现抽象类，咱们开发的代码实践才是真正的具体子类。1234public interface OCP &#123; void openExtention(); void closeModifiability();&#125; Q:What is OCP？A:OCP是啥咧？它告诉我们，咱们编写的代码应该面向扩展开放，而尽量不要通过修改现有代码来拥抱需求变更。这里，代码可以指的是一个功能模块，类，或者方法。Q:Why do we need to follow this principle？A:我们为什么要遵循OCP原则呢？地球人都知道代码后期需求变更的痛苦，如果不利用扩展来适应变更，那迎来的将是代码被修改的千疮百孔。Q:How do we practice this principle？A:我们如何实践这条原则？能用抽象类的别用具体类，能用接口的别用抽象类。总之一句：尽量面向接口编程。这里之所以说“尽量”是因为凡事都有度，别让你来个hello world你还给整个接口再实现。 talk is cheap，show your the code. 需求：老王开车去东北。 简单，开撸。 老王来了，大家藏好自己媳妇儿。123456789101112public class Laowang &#123; private Car car; private DongBei dongbei; ... getter() &amp; setter() ... public void drive() &#123; car.goto(dongbei); &#125;&#125; 要车就给你一辆咯 12345678public class Car &#123; public void goto(DongBei dongbei) &#123; System.out.println(“要去东北咯，啦啦啦”); // 模拟开车旅途消耗时间。10s就到东北了，开的可够快的啊！司机之前是开飞机的吗？ Thread.getCurrentThread().sleep(10 * 1000); System.out.println(“目的地东北到了”); &#125;&#125; 东北到了 123public class DongBei &#123; private String address = &quot;东北那旮沓儿&quot;;&#125; 老司机要发车了，赶紧打卡上车。滴，学生卡，咳咳咳，拿错卡了。 12345678public static void main(String[] args) &#123; Car car = new Car(); Laowang wang = new Laowang(); wang.setCar(car); DongBei dongbei = new DongBei(); wang.setDongbei(dongbei); wang.drive();&#125; Perfect，完美！现在需求变了，老王实现了2017年定下的小目标，挣了1个亿，买了架私人飞机，他不想开车去东北了，太low，他要开飞机去东北。 需求2：老王开飞机去东北 简单，给老王加个属性，加几个方法就实现了嘛？代码就不撸了。OK，又是一次完美变化！？需求又变了，老张和老王是穿一条裤裆长大的发小，老张看老王这都开上飞机了，他的车是不是可以借来开一开？ 需求3：老张开车去东北 这，这，这，简单，重新撸一遍老王在需求1的代码就行了，不就改个名的事吗？来来来，需求又变了，老张有急事去东北，老王就把飞机也借给老张用了。 需求4：老张开飞机去东北 这，这，这，这，这，这，简单，把老王在需求2的代码重撸一遍就是了。来来来，需求又变了，老王这回不去东北了，他想开飞机去广东那儿去探望下老丈人，顺便兜兜风。 需求5：老王开飞机去广东 需求6：老张开车去广东 需求7：老王要开飞机去美国 需求8：小王要开车去西藏 需求... 这，这，这，这这这，R&amp;D小哥一口老血喷在屏幕上，卒，享年25岁。 在这里，笔者建议，将人物，交通工具，目的地抽象化，接口化，就可以适应需求的频繁变更了。 上类图 OCP 客户端代码作如下调整：1234567891011121314public static void main(String[] args) &#123; // 想用地上开的交通工具出行，好，那就new个车给你开 ITransportation car = new Car(); // 这次是老王要出门 Person wang = new Laowang(); // 老王选择开车出行 wang.setTransportation(car); // 老王目的地是东北 AbsDestination dongbei = new DongBei(); dongbei.setAddressName(&quot;东北&quot;); wang.setDestination(dongbei); // 老司机开着车就出发了 wang.startOff();&#125; 老王的代码如下123456789public class Laowang extends Person&#123; ... public void startOff() &#123; this.transportation.transport(); System.out.println(&quot;出发咯&quot;); //thread.sleep(); System.out.println(&quot;目的地&quot; + this.destination.getAddressName() +&quot;到了.&quot;); &#125;&#125; 运行结果是： 出发咯 目的地东北到了. 现在，假如要做如上一些需求变更，在需求的变更过程中，客户端的代码变化是不是小多了呢？ 注意：开闭原则对扩展开放，对修改关闭，并不意味着不做任何修改，低层次模块的变化，必然要有高层模块进行耦合，否则就是一个孤立无意义的代码片段。在业务规则改变的情况下高层模块必须有部分改变以适应新业务，改变要尽量地少，放置变化风险的扩散—秦小波《设计模式之禅》 Single Responsibility Principle SRP原则（职责单一原则）:应该有且只有一个原因引起类的变更。123public interface SRP extends OCP &#123; void onlyDoOneThing();&#125; 通俗点来讲，一个类，一个方法只应该做一件事情。举2个栗子：1.当一个类A有R1，R2两个职责时，当R1的职责发生变更时，你需要修改类A，当R2发生变更时，你又需要修改类A，这时，已经有2个原因可能会引起类的变化了，类A就已经职责不单一了，就需要职责拆分，比如拆分成类A1，A2：A1类负责R1职责，A2类负责R2职责了。2.再比如有一个方法M，它即负责计算和打印两个职责123456public void M(int a, int b) &#123; int c = 0; c = a + b; System.out.println(&quot;打印的是 = &quot; + c); &#125; 有一天，你想要修改下计算规则，改为1c=a+b+1; 此时，你修改了方法M。又一天，你想修改下打印规则，改为1System.out.println(&quot;打印的是 = &quot; + （c+1）); 你又修改了方法M，此时，超过了2个原因让你去修改它，所以这个方法应该拆分为待返回值得计算calc方法和打印print两个方法。似的每个方法都只做一件事情。 那它是如何体现扩展性的呢？拿一个Android中最常见的ImageLoader的设计来举例子，ImageLoader主要需要实现2个功能，下载图片，缓存图片。假如，我们把所有的功能全部放在一个ImageLoader类中，假设下载要改方式呢？缓存要改策略呢？你通通要改ImageLoader，你如何保证修改某个功能的过程中另一个功能依旧完好，没被污染？拆分职责，使用ImageCache接口及其子类实现进行缓存，和ImageLoader建立关联，职责单一了，你再在每个单一的职责类里面去修改相关代码，这样其他功能代码被污染的概率大大降低。 当然，这里只是随意举的例子，划分单一职责这个度很难把握，每个人都需要根据自身情况和项目情况来进行判断。 Liskov Substitution Principle OCP原则(里氏替换原则)：所有引用基类的地方必须能透明地使用其子类的对象123public interface LSP extends OCP &#123; void liskovSubstitutionPrinciple();&#125; 通俗点讲：只要父类能出现的地方子类就可以出现，而且替换为子类也不产生任何异常错误，反之则不然。这主要体现在，我们经常使用抽象类/基类做为方法参数，具体使用哪个子类作为参数传入进去，由调用者决定。 这条原则包含以下几个方面： 子类必须完全实现父类的方法 子类可以有自己的个性外观（属性）和行为（方法） 覆盖或者实现父类方法时，参数可以被放大。即父类的某个方法参数为HashMap时，子类参数可以是HashMap，也可以是Map或者更大 覆盖或者实现父类的方法时，返回结果可以被缩小。即父类的某个方法返回类型是Map，子类可以是Map，也可以是HashMap或者更小。 Dependence Inversion Principle DIP原则（依赖倒置原则）：高层模块不要依赖低层模块，所以依赖都应该是抽象的，抽象不应该依赖于具体细节而，具体细节应该依赖于抽象 底层模块：不可分割的原子逻辑就是低层模块高层模块：低层模块的组装合成后就是高层模块 抽象：Java中体现为基类，抽象类，接口，而不单指抽象类细节：体现为子类，实现类 通俗点讲，该原则包含以下几点要素： 模块间的依赖应该通过抽象发生，具体实现类之间不应该建立依赖关系 接口或者抽象类不依赖于实现类，否则就失去了抽象的意义 实现类依赖于接口或者抽象类 总结起来，一句话：”面向接口编程“。 Interface-Segregation Principle ISP原则（接口隔离原则）:客户端不应该依赖它不需要的接口；类间的依赖应该建立在最小的接口上 通俗点讲：使用接口时应该建立单一接口，不要建立臃肿庞大的接口，尽量给调用者提供专门的接口，而非多功能接口。 这里我想举个例子就是Android中的事件处理Listener设计，大家都知道，我们想给button添加点击事件时，可以使用如下代码 1button.setOnClickListener(clickListener); 想给它添加长按事件时，可以使用如下代码 1button.setOnLongClickListener(longClickListener); 还有其他比如OnTouchListener等等等事件接口，它为什么不直接提供一个通用的接口IListener呢？然后回调所有的事件给调用者处理，而要提供这么多独立的接口，这就是遵循了ISP原则的结果，每个接口最小化了，Activity/button作为调用者，我可以选择性的去处理我想处理的事件，不关心的事件Listener我就不去处理，依赖。 Low of Demeter LoD法则（迪米特法则）：又称最少知识原则（Least Knowledge Principle， LKP），一个对象应该对其他对象有最少的了解。 通俗点讲：一个类应该对自己需要耦合或者调用的类知道越少越好，被耦合或者调用的类内部和我没有关系，我不需要的东西你就别public了吧。 迪米特法则包含以下几点要素： 只和朋友类交流：只耦合该耦合的类 朋友间也是有距离的：减少不该public的方法，向外提供一个简洁的访问 自家的方法就自己创建：只要该方法不会增加内部的负担，也不会增加类间耦合 感谢和参考秦小波：《设计模式之禅》Mr.simple：《Android 源码设计模式解析与实战》java-my-life:http://www.cnblogs.com/java-my-life/…… 后话规则只是规则，大家不应该死守规则，应该持辩证的态度去看待这6大原则，才能更好地达到实践应用的目的。感谢以上作者和博客的规范化引导以及诸多博主的博客才渐渐让我懂得实践设计模式与应用架构。笔者将会未来陆续更新《设计模式系列》in Android博客，后续博客中，均参考了以上书籍和博客。欢迎各位朋友评论区点赞拍砖交流。","categories":[{"name":"Design Pattern","slug":"Design-Pattern","permalink":"https://xiong-it.github.io/categories/Design-Pattern/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://xiong-it.github.io/tags/设计模式/"},{"name":"Design Pattern","slug":"Design-Pattern","permalink":"https://xiong-it.github.io/tags/Design-Pattern/"},{"name":"6大原则","slug":"6大原则","permalink":"https://xiong-it.github.io/tags/6大原则/"},{"name":"OOP","slug":"OOP","permalink":"https://xiong-it.github.io/tags/OOP/"}]}]}