<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>MichaelX&#39;s Blog</title>
  <subtitle>MichaelX的开发博客</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://blog.michaelx.tech/"/>
  <updated>2017-05-12T09:35:11.001Z</updated>
  <id>http://blog.michaelx.tech/</id>
  
  <author>
    <name>MichaelX</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Android开发：使用AutoInputAuthCode快速实现自动填写验证码</title>
    <link href="http://blog.michaelx.tech/2017-05/Android%E5%BC%80%E5%8F%91%EF%BC%9A%E4%BD%BF%E7%94%A8AutoInputAuthCode%E5%BF%AB%E9%80%9F%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%8A%A8%E5%A1%AB%E5%86%99%E9%AA%8C%E8%AF%81%E7%A0%81/"/>
    <id>http://blog.michaelx.tech/2017-05/Android开发：使用AutoInputAuthCode快速实现自动填写验证码/</id>
    <published>2017-05-09T09:36:18.000Z</published>
    <updated>2017-05-12T09:35:11.001Z</updated>
    
    <content type="html"><![CDATA[<p>使用AutoInputAuthCode快速实现自动填写验证码<br><a id="more"></a></p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>该类库的实现原理:<a href="http://blog.csdn.net/xiong_it/article/details/50997084" target="_blank" rel="external">《Android开发:实现APP自动填写注册验证码功能》</a>。感兴趣的可以看下。  </p>
<p>项目地址：<a href="https://github.com/xiong-it/AutoInputAuthCode" target="_blank" rel="external">https://github.com/xiong-it/AutoInputAuthCode</a></p>
<blockquote>
<p>本文原创作者:<a href="http://blog.csdn.net/xiong_it" target="_blank" rel="external">MichaelX</a>,博客地址:<a href="http://blog.csdn.net/xiong_it.转载请注明来源" target="_blank" rel="external">http://blog.csdn.net/xiong_it.转载请注明来源</a></p>
</blockquote>
<hr>
<h1 id="AutoInputAuthCode使用介绍"><a href="#AutoInputAuthCode使用介绍" class="headerlink" title="AutoInputAuthCode使用介绍"></a>AutoInputAuthCode使用介绍</h1><p>在Android Studio打开你的app module中的build.gradle,添加依赖：<br><figure class="highlight gradle"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">dependencies</span> &#123;</div><div class="line">   ...</div><div class="line">   <span class="keyword">compile</span> <span class="string">'tech.michaelx.authcode:authcode:1.0.0'</span> <span class="comment">// 添加依赖</span></div><div class="line">   ...</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>如果无法下载上述依赖，可以打开你的项目根目录下的build.gradle，添加maven仓库地址<br><figure class="highlight gradle"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">allprojects</span> &#123;</div><div class="line">    <span class="keyword">repositories</span> &#123;</div><div class="line">        jcenter()</div><div class="line">        maven &#123; url <span class="string">'https://dl.bintray.com/xiong-it/AndroidRepo'</span>&#125; <span class="comment">// 添加这行</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1 id="示范代码"><a href="#示范代码" class="headerlink" title="示范代码"></a>示范代码</h1><p>AutoInputAuthCode是一个帮助Android开发者快速实现自动填写验证码的类库，客户端示例代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">CodeConfig config = <span class="keyword">new</span> CodeConfig.Builder()</div><div class="line">                        .codeLength(<span class="number">4</span>) <span class="comment">// 设置验证码长度</span></div><div class="line">                        .smsFromStart(<span class="number">133</span>) <span class="comment">// 设置验证码发送号码前几位数字</span></div><div class="line">                        <span class="comment">//.smsFrom(1690123456789) // 如果验证码发送号码固定，则可以设置验证码发送完整号码</span></div><div class="line">                        .smsBodyStartWith(<span class="string">"百度科技"</span>) <span class="comment">// 设置验证码短信开头文字</span></div><div class="line">                        .smsBodyContains(<span class="string">"验证码"</span>) <span class="comment">// 设置验证码短信内容包含文字</span></div><div class="line">                        .build();</div><div class="line">                        </div><div class="line">AuthCode.getInstance().with(context).config(config).into(EditText);</div></pre></td></tr></table></figure></p>
<ol>
<li>通过单例获取一个AuthCode对象;</li>
<li>提供一个上下文对象给AuthCode，放心，我会妥善处理你的上下文;</li>
<li>提供一个你的验证码特征描述;</li>
<li>告诉AuthCode你想将验证码写入哪个EditText.</li>
</ol>
<p>搞定，收工！  </p>
<h1 id="效果图"><a href="#效果图" class="headerlink" title="效果图"></a>效果图</h1><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="http://oler3nq5z.bkt.clouddn.com/authcode2.gif" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>
<h1 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h1><p>自动填写验证码需要读取短信权限，请在清单中添加权限：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">"android.permission.READ_SMS"</span>/&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">"android.permission.READ_SMS"</span>/&gt;</span></div></pre></td></tr></table></figure></p>
<p>由于读取短信在API 23（Android 6.0）上权限级别是<strong>dangerous</strong>。所以还需要动态申请权限，但是申请权限需要依赖于Activity或者Fragment中的onRequestPermissionsResult()回调，所以需要开发者自己实现。  </p>
<p>可参考<a href="https://github.com/xiong-it/AutoInputAuthCode" target="_blank" rel="external">AutoInputAuthCode</a>中sample的代码。</p>
<p>该库实现原理请参考：<a href="http://blog.csdn.net/xiong_it/article/details/50997084" target="_blank" rel="external">《Android开发:实现APP自动填写注册验证码功能》</a></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>该库实际上被完成有一段时间了，一直在试着上传jcenter，有空把上传代码到jcenter总结下发出来，虽然上传jcenter在网上教程挺多的，但是很多都不够细节，容易误解，我就是被坑的一个。  </p>
<p>祝大家撸码愉快！<br>项目地址：<a href="https://github.com/xiong-it/AutoInputAuthCode" target="_blank" rel="external">https://github.com/xiong-it/AutoInputAuthCode</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;使用AutoInputAuthCode快速实现自动填写验证码&lt;br&gt;
    
    </summary>
    
      <category term="开源" scheme="http://blog.michaelx.tech/categories/%E5%BC%80%E6%BA%90/"/>
    
    
      <category term="AutoInputAuthCode" scheme="http://blog.michaelx.tech/tags/AutoInputAuthCode/"/>
    
      <category term="验证码" scheme="http://blog.michaelx.tech/tags/%E9%AA%8C%E8%AF%81%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>科学上网:安装Shadowsocks Server on VPS</title>
    <link href="http://blog.michaelx.tech/2017-05/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91-%E5%AE%89%E8%A3%85Shadowsocks-Server-on-VPS/"/>
    <id>http://blog.michaelx.tech/2017-05/科学上网-安装Shadowsocks-Server-on-VPS/</id>
    <published>2017-05-03T08:46:37.000Z</published>
    <updated>2017-05-16T07:48:30.405Z</updated>
    
    <content type="html"><![CDATA[<p>作为一名开发者，科学上网是一个很强的诉求，至今被|墙的google，偶尔抽风的github，当然你要想着看小片，全球最大的xx网站也在墙外<br><a id="more"></a></p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>作为一名开发者，科学上网是一个很强的诉求，至今被|墙的google，偶尔抽风的github，当然你要想着看小片，全球最大的xx网站也在墙外。科学上网的方法大致如下几种：</p>
<ol>
<li>修改本机hosts，可访问的网站有限</li>
<li>vpn：容易被封</li>
<li>shadowsocks-俗称：影梭</li>
<li>etc…</li>
</ol>
<h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>其中修改hosts的方法成本最低，也最简单，网上找到需要访问网站的ip，写进本机hosts文件中即可。这样访问被|墙网站时，机器先访问hosts文件，发现已经有ip了，就不会访问dns服务器去要求解析域名了，而是直接根据指定ip去访问被|墙网站。<br>vpn的方式由于其容易被探测的缘故，容易被封。<br>根据socks5代理方式实现的shadowsocks项目，由于其隐蔽性存活至今。其需要一外国的服务器上装shadowsocks服务端实现流量中转，然后本地机器装shadowsocks客户端进行科学上网。当然网上也有很多的shadowsocks账号购买，服务器它给你搭好了，然后就售卖账号，但是也存在些骗子收完钱跑路的，拿着账号上不了网，当然也存在奸商超售账号的情况，许多人买完账号挤在一个服务器上爬蜗牛。那么为什么不自己搭一个shadowsocks服务端呢？更何况年付的价钱不比你购买账号贵！服务器还在自己手里，不怕隐私泄露。</p>
<h1 id="什么是vps"><a href="#什么是vps" class="headerlink" title="什么是vps"></a>什么是vps</h1><p>笔者理解也不深，感觉就是虚拟主机的升级版，可拥有独立ip，但又不是独立服务器，是一台服务器上利用虚拟化技术独立出来的单独机器，购买这台vps后，你自己就可以对这台机器做任意操作：重装系统（Linux，Windows），装任意软件，拥有root权限，可远程操控都不在话下。总之和一台远程服务器差不多。但是价格却远低于服务器价格。搬瓦工VPS的介绍翻译如下：</p>
<blockquote>
<p> 隶属于美国IT7公司旗下的一款低价OpenVZ VPS主机方案、2017年新增KVM VPS架构，尤其是6款便宜年付VPS，无论从性价比还是稳定性都非常适合大众VPS用户需求，我们可以用来建站、搭建上网环境</p>
</blockquote>
<p>官网：<a href="https://bandwagonhost.com/aff.php?aff=14794" target="_blank" rel="external">性价比高*搬瓦工vps</a></p>
<p>笔者购买的是最便宜的年付19刀（人民币130左右）的512M内存，10G ssd硬盘，100G宽带方案，难能可贵的是搬瓦工vps：可使用<strong>支付宝</strong>支付，据说是2016年推出的新功能，之前只能使用PayPal支付。</p>
<hr>
<h1 id="购买搬瓦工VPS"><a href="#购买搬瓦工VPS" class="headerlink" title="购买搬瓦工VPS"></a>购买搬瓦工VPS</h1><ol>
<li>打开搬瓦工官网：<a href="https://bandwagonhost.com/aff.php?aff=14794" target="_blank" rel="external">性价比高*搬瓦工vps</a></li>
<li>点击要购买的的套餐下方的 订购按钮“order Now”，<br><img src="http://oler3nq5z.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-04-27%20%E4%B8%8B%E5%8D%888.06.23.png" alt=""></li>
<li>进入如下图示界面，选择付账周期Billing Cycle（月付，季付，半年付，年付），和<br>节点Location（洛杉矶，佛罗里达等），洛杉矶的节点还行，比较稳定。最后点击Add to Cart加入购物车，之后下一个界面点击check out结账。<br><img src="http://oler3nq5z.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-04-27%20%E4%B8%8B%E5%8D%888.07.44.png" alt=""></li>
<li>注册账号<br>有几点：<ul>
<li>资料是否完全真实无所谓，姓名可以随意填</li>
<li>邮箱必须自己的，以免以后找回密码需要</li>
<li>国家、地区、省份必须真实</li>
<li>街道等详细地址你随意填写，电话也可以随意。不能用V=P=N软件更换IP购买，用真实的IP购买就可以。</li>
<li>Pay Method中选择Alipay即支付宝，勾选下方的协议</li>
<li>点击Complete Order结账</li>
<li>手机支付宝扫二维码，完事<br><img src="http://oler3nq5z.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-04-27%20%E4%B8%8B%E5%8D%888.20.39.png" alt=""></li>
</ul>
</li>
</ol>
<h1 id="搬瓦工VPS安装shadowsocks服务端"><a href="#搬瓦工VPS安装shadowsocks服务端" class="headerlink" title="搬瓦工VPS安装shadowsocks服务端"></a>搬瓦工VPS安装shadowsocks服务端</h1><ol>
<li>点击图中的Client Area，登陆账号<br><img src="http://oler3nq5z.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-04-27%20%E4%B8%8B%E5%8D%888.23.57.png" alt=""></li>
<li>查看服务<br><img src="http://oler3nq5z.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-04-27%20%E4%B8%8B%E5%8D%888.25.16.png" alt=""></li>
<li>点击右边的KiviVM Control Panel进入vps控制面板<br><img src="http://oler3nq5z.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-04-27%20%E4%B8%8B%E5%8D%888.27.36.png" alt=""></li>
<li>安装shadowsocks Server<br><img src="http://oler3nq5z.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-04-27%20%E4%B8%8B%E5%8D%888.29.14.png" alt="此处输入图片的描述"></li>
</ol>
<h1 id="ss客户端使用"><a href="#ss客户端使用" class="headerlink" title="ss客户端使用"></a>ss客户端使用</h1><p><a href="https://github.com/shadowsocks" target="_blank" rel="external">ss客户端下载</a><br><a href="https://github.com/shadowsocks/shadowsocks-windows/wiki/Shadowsocks-Windows-%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E" target="_blank" rel="external">ss客户端使用</a></p>
<h1 id="参考博客"><a href="#参考博客" class="headerlink" title="参考博客"></a>参考博客</h1><p><a href="https://b.lhuac.com/2/" target="_blank" rel="external">https://b.lhuac.com/2/</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;作为一名开发者，科学上网是一个很强的诉求，至今被|墙的google，偶尔抽风的github，当然你要想着看小片，全球最大的xx网站也在墙外&lt;br&gt;
    
    </summary>
    
      <category term="科学上网" scheme="http://blog.michaelx.tech/categories/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/"/>
    
    
      <category term="科学上网" scheme="http://blog.michaelx.tech/tags/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/"/>
    
      <category term="Shadowsocks" scheme="http://blog.michaelx.tech/tags/Shadowsocks/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu 14.04编译AOSP for Nexus/Pixel</title>
    <link href="http://blog.michaelx.tech/2017-03/Ubuntu-14-04%E7%BC%96%E8%AF%91AOSP-for-Nexus-Pixel/"/>
    <id>http://blog.michaelx.tech/2017-03/Ubuntu-14-04编译AOSP-for-Nexus-Pixel/</id>
    <published>2017-03-14T03:29:09.000Z</published>
    <updated>2017-05-03T08:21:21.752Z</updated>
    
    <content type="html"><![CDATA[<p>为你手中的Nexus,Pixel手机刷入自己的专属Rom<br><a id="more"></a></p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>虽说几年前博主在一家公司做机顶盒的时候总是需要编译Android源码，但是那时还没有手中的爱机：Nexus 6，又名shamu。今天我要为它刷入一个自己编译的Rom。拿起键盘就是干。</p>
<blockquote>
<p>笔者注：AOSP:Android Open Source Project，安卓开源项目</p>
</blockquote>
<h1 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h1><ul>
<li>Ubuntu 14.04+</li>
<li>OpenJDK/JDK</li>
<li>Nexus/Pixel手机一部</li>
</ul>
<p>假设你已经有了一个较新的Ubuntu系统和一部谷歌亲儿子手机，下文将从安装jdk开始。</p>
<blockquote>
<p>本文作者MichaelX，博客地址：<a href="http://blog.csdn.net/xiong_it" target="_blank" rel="external">http://blog.csdn.net/xiong_it</a> ，转载请注明出处。</p>
</blockquote>
<hr>
<h1 id="AOSP编译环境搭建"><a href="#AOSP编译环境搭建" class="headerlink" title="AOSP编译环境搭建"></a>AOSP编译环境搭建</h1><h2 id="安装OpenJDK"><a href="#安装OpenJDK" class="headerlink" title="安装OpenJDK"></a>安装OpenJDK</h2><blockquote>
<p><strong>警告</strong>：不要使用oracle jdk来编译较新（API 21+/Android 5.0及以上）的AOSP，会在准备编译工作<strong>make</strong> <strong>clobber</strong>时出现错误提示.</p>
</blockquote>
<pre><code>Checking build tools versions...
*************************************************************
You asked for an OpenJDK based build but your version is java version &quot;1.8.0_121&quot; Java(TM) SE Runtime Environment(build 1.8.0_121-b13)Java HotSpot (TM)64 bit Server VM(build 25.121-b13), mixed mode).
*************************************************************
build/core/main.mk:230: *** stop.
</code></pre><p>关于<strong>JDK版本</strong>的选择：<strong>根据你想编译的Android版本来决定</strong></p>
<ul>
<li>AOSP最新源码: OpenJDK 8</li>
<li>Android 5.x (Lollipop) - Android 6.0 (Marshmallow):OpenJDK 7</li>
<li>Android 2.3.x (Gingerbread) - Android 4.4.x(KitKat):Java JDK 6</li>
<li>Android 1.5 (Cupcake) - Android 2.2.x (Froyo): Java JDK 5</li>
</ul>
<p>博主想要编译的是Android 7.0，所以需要使用是OpenJDK 8。</p>
<p>博主是用的Ubuntu 14.04 LTS，可采取安装deb包或者添加ppa两种方式安装OpenOJDK 8：</p>
<ol>
<li>OpenJDK deb包下载:<a href="https://github.com/xiong-it/buildAOSP/tree/master/OpenJDK8" target="_blank" rel="external">OpenJDK 8 on github</a></li>
<li>添加ppa方式安装OpenJDK<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">$ sudo add-apt-repository ppa:openjdk-r/ppa</div><div class="line">$ sudo apt-get update</div><div class="line"></div><div class="line">$ sudo apt-get install openjdk-8-jdk</div><div class="line"></div><div class="line">$ sudo update-alternatives --config java</div><div class="line">$ sudo update-alternatives --config javac</div></pre></td></tr></table></figure>
</li>
</ol>
<p>假如你Ubuntu是15.04或者更新的系统，可直接运行下列命令进行OpenJDK 8安装</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ sudo apt-get update</div><div class="line">$ sudo apt-get install openjdk-8-jdk</div></pre></td></tr></table></figure>
<p>Linux使用下列命令查看机器中所有jdk版本<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ michaelx@michaelx-ThinkPad:~/AOSP_NBD91Z$ update-java-alternatives -l</div><div class="line">// 打印出下面已安装的jdk版本</div><div class="line">java-1.8.0-openjdk-amd64 1069 /usr/lib/jvm/java-1.8.0-openjdk-amd64</div></pre></td></tr></table></figure></p>
<p>Linux设置默认JDK命令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">// 设置默认为openjdk8，此处必须选用OpenJDK8</div><div class="line">$ sudo update-java-alternatives -s java-1.8.0-openjdk-amd64</div><div class="line">// 设置默认为oracle jdk8</div><div class="line">$ sudo update-java-alternatives -s java-8-oracle</div><div class="line">// 设置默认为oracle jdk7</div><div class="line">$ sudo update-java-alternatives -s java-7-oracle</div></pre></td></tr></table></figure></p>
<p>Ubuntu 14.04设置默认OpenJDK 8时出现一处警告提示：</p>
<pre><code>update-java-alternatives: plugin alternative does not exist: /usr/lib/jvm/java-8-openjdk-amd64/jre/lib/amd64/IcedTeaPlugin.so
</code></pre><p>该提示无需理会，可直接忽略。</p>
<p>查看Java版本，出现以下提示，说明jdk环境已经ok。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$ java -version</div><div class="line"></div><div class="line">openjdk version &quot;1.8.0_111&quot;</div><div class="line">OpenJDK Runtime Environment (build 1.8.0_111-8u111-b14-3~14.04.1-b14)</div><div class="line">OpenJDK 64-Bit Server VM (build 25.111-b14, mixed mode)</div></pre></td></tr></table></figure></p>
<p>如果实在切换不了默认jdk，就像博主一样，卸了oracle jdk吧。</p>
<h2 id="安装必要软件"><a href="#安装必要软件" class="headerlink" title="安装必要软件"></a>安装必要软件</h2><p>在你的Ubuntu 14(x64)上执行以下命令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ sudo apt-get install git-core gnupg flex bison gperf build-essential \</div><div class="line">  zip curl zlib1g-dev gcc-multilib g++-multilib libc6-dev-i386 \</div><div class="line">  lib32ncurses5-dev x11proto-core-dev libx11-dev lib32z-dev ccache \</div><div class="line">  libgl1-mesa-dev libxml2-utils xsltproc unzip</div></pre></td></tr></table></figure></p>
<p>会有些已经安装，有些无法安装，或者安装失败，无需理会，继续往下。其他系统版本系统请直接参考：<a href="https://source.android.com/source/initializing.html" target="_blank" rel="external">Establishing a build environment</a></p>
<h2 id="配置USB访问权限"><a href="#配置USB访问权限" class="headerlink" title="配置USB访问权限"></a>配置USB访问权限</h2><p>ps：不知道这个干啥的，但是官方是这么建议的，为了让普通用户可访问usb设备。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ wget -S -O - http://source.android.com/source/51-android.rules | sed &quot;s/&lt;username&gt;/$USER/&quot; | sudo tee &gt;/dev/null /etc/udev/rules.d/51-android.rules; sudo udevadm control --reload-rules</div></pre></td></tr></table></figure></p>
<hr>
<h1 id="安装repo"><a href="#安装repo" class="headerlink" title="安装repo"></a>安装repo</h1><p>安装repo以下载AOSP源码。repo是Google根据git开发来专门管理Android源码用的，具有断点续传的特性。其主要命令可参考：<a href="http://blog.csdn.net/xiong_it/article/details/45173987" target="_blank" rel="external">git/repo常用命令一览</a>。依次执行下面命令。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">$ cd ~</div><div class="line">$ mkdir bin</div><div class="line">$ PATH=~/bin:$PATH</div><div class="line"></div><div class="line">$ curl https://storage.googleapis.com/git-repo-downloads/repo &gt; ~/bin/repo</div><div class="line">$ chmod a+x ~/bin/repo # 给repo添加执行权限</div></pre></td></tr></table></figure></p>
<h1 id="配置git"><a href="#配置git" class="headerlink" title="配置git"></a>配置git</h1><p>由于需要下载Android源码，你需要事先准备好一个google的<a href="https://www.google.com/gmail/" target="_blank" rel="external">gmail邮箱</a>。执行以下命令配置git用户名和gmail邮箱。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ git config --global user.name &quot;Your Name&quot;</div><div class="line">$ git config --global user.email &quot;you@gmail.com&quot;</div></pre></td></tr></table></figure></p>
<p>配置Google的git cookies访问权限，以便大量下载aosp源码站点资源。<br><a href="https://android.googlesource.com/new-password" target="_blank" rel="external">https://android.googlesource.com/new-password</a><br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="http://img.blog.csdn.net/20170312103501761?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvWGlvbmdfSVQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="configure" title="">
                </div>
                <div class="image-caption">configure</div>
            </figure><br>复制框中的命令,粘贴到终端,执行。</p>
<hr>
<h1 id="下载AOSP源码"><a href="#下载AOSP源码" class="headerlink" title="下载AOSP源码"></a>下载AOSP源码</h1><p><strong>创建一个目录以存放Android源码</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ mkdir ~/AOSP_NBD91Z # 目录名请自行定义，本文以AOSP_NBD91ZNBD91Z为例</div><div class="line">$ cd AOSP_NBD91Z</div></pre></td></tr></table></figure></p>
<p>根据手中的机器和以下两个连接进行<strong>repo分支选择</strong>：<br><a href="https://source.android.com/source/build-numbers.html" target="_blank" rel="external">https://source.android.com/source/build-numbers.html</a><br><a href="https://developers.google.com/android/nexus/drivers" target="_blank" rel="external">https://developers.google.com/android/nexus/drivers</a></p>
<p>AOSP源码编译默认是不适配驱动的，只适合模拟器运行，由于博主想要为Nexus 6编译，所以需要考虑驱动问题，根据上文第二个链接找到shamu的最新驱动，目前（20170307）最新的驱动支持到build NBD91Z，将<strong>驱动下载下来，留着备用</strong>。<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="http://img.blog.csdn.net/20170312115424282?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvWGlvbmdfSVQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述" title="">
                </div>
                <div class="image-caption">这里写图片描述</div>
            </figure><br>在第一个链接中找到对应的branch name（<strong>android-7.0.0_r29</strong>）。<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="http://img.blog.csdn.net/20170312140527859?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvWGlvbmdfSVQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述" title="">
                </div>
                <div class="image-caption">这里写图片描述</div>
            </figure></p>
<p><strong>在AOSP本地目录初始化repo分支</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ cd ~/AOSP_NBD91Z</div><div class="line">$ repo init -u https://android.googlesource.com/platform/manifest -b android-7.0.0_r29</div></pre></td></tr></table></figure></p>
<p><strong>下载/续传AOSP源码</strong><br>无论是第一次开始下载，还是中途断掉后接着续传下载，都是执行以下命令。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ repo sync</div></pre></td></tr></table></figure></p>
<p>之后就是漫长的等待了，该分支（android-7.0.0_r29）代码总共约80G（含版本管理文件.repo目录46G）。<br>这里提醒下各位，分区的时候一定记得至少至少至少给到120G啊，80G还不是最新分支的大小呢。编译后更加大得多：该分支编译出的out目录共30G左右。<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="http://img.blog.csdn.net/20170312140830563?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvWGlvbmdfSVQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述" title="">
                </div>
                <div class="image-caption">这里写图片描述</div>
            </figure><br>不过下载完成后，如果没什么版本控制的需要 .repo目录倒是可以删除掉，节省点硬盘空间。</p>
<hr>
<h1 id="编译AOSP预备工作"><a href="#编译AOSP预备工作" class="headerlink" title="编译AOSP预备工作"></a>编译AOSP预备工作</h1><p><strong>设置编译缓存（可选操作）</strong><br>可加速后续第二次编译，如需要，可在源码目录执行以下命令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ export USE_CCACHE=1</div><div class="line">$ export CCACHE_DIR=~/AOSP_NBD91Z/.ccache # 目录自定义</div><div class="line">$ prebuilts/misc/linux-x86/ccache/ccache -M 50G # 官方推荐50-100G</div></pre></td></tr></table></figure></p>
<p>更新环境变量<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$ vim ~/.bashrc</div><div class="line"># 添加以下这行</div><div class="line">export USE_CCACHE=1</div><div class="line"></div><div class="line">$ source ~/.bashrc</div></pre></td></tr></table></figure></p>
<p><strong>释放手机驱动</strong><br>将上述下载的几个驱动文件解压到<code>源码根目录</code>，解压后也就是几个脚本文件，依次执行，以释放驱动，画风大概如下<br>{% image http://img.blog.csdn.net/20170312141135768?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvWGlvbmdfSVQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast 释放shamu驱动  %}</p>
{% image http://img.blog.csdn.net/20170312213814287?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvWGlvbmdfSVQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast 释放shamu驱动  %}
{% image http://img.blog.csdn.net/20170312184550739?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvWGlvbmdfSVQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast 释放shamu驱动  %}
<p>共8大条款，几十个小条款，一行行回车按过去，心累啊。</p>
<blockquote>
<p>划重点：在执行驱动脚本后，会让你看一大长串协议，最后你需要输入：<strong>I ACCEPT</strong> 来同意驱动的协议，方可释放驱动文件。按回车按快了则提示你没有同意，驱动未释放成功。成功之后会多出一个vendor目录。</p>
</blockquote>
<p><strong>清理编译文件</strong><br>驱动释放完毕，先执行<code>make clobber</code>清理下编译后文件的目录，第一次编译其实博主觉得这个命令无所谓。</p>
<blockquote>
<p>相似命令：<code>make clean</code> 它清理out/target/product/[product_name]目录。</p>
</blockquote>
<hr>
<h1 id="编译AOSP"><a href="#编译AOSP" class="headerlink" title="编译AOSP"></a>编译AOSP</h1><p><strong>准备好编译平台</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ cd AOSP_NBD91Z</div><div class="line">$ source build/envsetup.sh</div><div class="line"># or 或者，上面的命令和下面的命令等价</div><div class="line">$ . build/envsetup.sh</div></pre></td></tr></table></figure></p>
<p><strong>选择编译平台</strong><br>执行上述命令后方可执行这条命令<code>lunch</code><br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="http://img.blog.csdn.net/20170312141046014?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvWGlvbmdfSVQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="lunch" title="">
                </div>
                <div class="image-caption">lunch</div>
            </figure><br>由于笔者手中是Nexus 6（shamu），所以果断选择了21</p>
<p><strong>关于几种模式的区别</strong></p>
<ul>
<li>user 正常模式，给普通用户用的</li>
<li>userdebug    具备root权限和更多调试功能，其他和user模式无异</li>
<li>eng    开发者的最佳选项，具有许多额外的调试工具</li>
</ul>
<p><strong>正式编译AOSP源码</strong><br>运行<code>make</code>进行编译，也可以使用-j选项指定并行编译线程数量<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"># 利用6个线程进行编译。官方建议的最快并行线程数量为：j16-j32之间。</div><div class="line">$ make -j6 </div><div class="line"></div><div class="line"># 请各位根据自身CPU性能量力而行。博主曾经使用-j16导致GUI界面和终端统统卡死，只能强制关机，心疼我的ssd硬盘30s。</div></pre></td></tr></table></figure></p>
<p>又是一次漫长的等待啊，如果不出什么问题，那么在<code>out/target/product/[product_name]/</code>目录下将会多出诸如system.img，recovery.img等等，就可以愉快的刷机了。<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="http://img.blog.csdn.net/20170312215601142?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvWGlvbmdfSVQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="build-aosp-successful" title="">
                </div>
                <div class="image-caption">build-aosp-successful</div>
            </figure></p>
<p>下面是生成的各种镜像文件和其他。<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="http://img.blog.csdn.net/20170312215818926?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvWGlvbmdfSVQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="out-dir-files" title="">
                </div>
                <div class="image-caption">out-dir-files</div>
            </figure></p>
<hr>
<h1 id="编译AOSP遇到的问题"><a href="#编译AOSP遇到的问题" class="headerlink" title="编译AOSP遇到的问题"></a>编译AOSP遇到的问题</h1><p><strong>权限遭拒</strong><br>由于博客使用了外部硬盘作为out编译输出，<code>make</code>时提示Permission is denied。这时换成<code>sudo make</code>即可。</p>
<blockquote>
<p>使用外部磁盘做out输出：export OUT_DIR_COMMON_BASE=/media/username/外部磁盘路径/out</p>
</blockquote>
<p><strong>内存不足</strong><br>由于笔者的内存只有4G，并且最开始没有分出swap分区，导致多次内存不足编译失败，有多种日志形式都表明内存不足：</p>
<p>第1种错误：<br><code>[ 34% 12287/35393] Building with Jack: out/target/common/obj/JAVA_LIBRARIES/core-all_intermediates/with-local/classes.dex
FAILED: /bin/bash out/target/common/obj/JAVA_LIBRARIES/core-all_intermediates/with-local/classes.dex.rsp
Communication error with Jack server (52). Try &#39;jack-diagnose&#39;
ninja: build stopped: subcommand failed.
make: *** [ninja_wrapper] Error 1</code></p>
<p>第2种错误：<br><code>[ 82% 30024/36285] Aligning zip: out/target/product/shamu/obj/SHARED_LIBRARIES/libdlext_test_runpath_zip_zipaligned_intermediates/libdlext_test_runpath_zip_zipaligned.zip
[ 82% 30025/36285] Import includes file: out/target/product/shamu/obj/STATIC_LIBRARIES/libverifier_intermediates/import_includes
[ 82% 30026/36285] target thumb C++: libverifier &lt;= bootable/recovery/asn1_decoder.cpp
[ 82% 30027/36285] target thumb C++: libverifier &lt;= bootable/recovery/verifier.cpp
[ 82% 30028/36285] Export includes file:  -- out/target/product/shamu/obj/STATIC_LIBRARIES/libverifier_intermediates/export_includes
[ 82% 30029/36285] target thumb C++: libverifier &lt;= bootable/recovery/ui.cpp
ninja: fatal: fork: Cannot allocate memory
make: *** [ninja_wrapper] Error 1</code></p>
<p>第3种错误：<br><code>FAILED: /bin/bash out/target/common/obj/JAVA_LIBRARIES/core-all_intermediates/with-local/classes.dex.rsp
Out of memory error (version 1.2-rc4 &#39;Carnac&#39; (298900 f95d7bdecfceb327f9d201a1348397ed8a843843 by android-jack-team@google.com)).
GC overhead limit exceeded.
Try increasing heap size with java option &#39;-Xmx&lt;size&gt;&#39;.
Warning: This may have produced partial or corrupted output.
[ 31% 11494/36285] host C++: libartd-compiler &lt;= art/compiler/optimizing/graph_visualizer.cc
[ 31% 11494/36285] Building with Jack: out/target/common/obj/JAVA_LIBRARIES/libprotobuf-java-nano_intermediates/classes.jack
[ 31% 11494/36285] build out/target/common/obj/JAVA_LIBRARIES/sdk_v21_intermediates/classes.jack
ninja: build stopped: subcommand failed.</code></p>
<p>第4种错误：<br><code>[  6% 2375/35393] target Java: icu4j (out/target/common/obj/JAVA_LIBRARIES/icu4j_intermediates/classes)
Note: Some input files use or override a deprecated API.
Note: Recompile with -Xlint:deprecation for details.
Note: external/icu/icu4j/main/classes/core/src/com/ibm/icu/impl/Relation.java uses unchecked or unsafe operations.
Note: Recompile with -Xlint:unchecked for details.
[  6% 2394/35393] host C++: libLLVMMC_32 &lt;= external/llvm/lib/MC/MCDwarf.cppninja: fatal: fork: Cannot allocate memory
make: *** [ninja_wrapper] Error 1</code></p>
<p>第5种错误：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">[  5% 1883/35393] Docs droiddoc: out/target/common/docs/api-stubs</div><div class="line">FAILED: /bin/bash out/target/common/docs/api-stubs-timestamp.rsp</div><div class="line">OpenJDK 64-Bit Server VM warning: INFO: os::commit_memory(0x00000000bdb80000, 72876032, 0) failed; error=&apos;Cannot allocate memory&apos; (errno=12)</div><div class="line">#</div><div class="line"># There is insufficient memory for the Java Runtime Environment to continue.</div><div class="line"># Native memory allocation (mmap) failed to map 72876032 bytes for committing reserved memory.</div><div class="line"># An error report file with more information is saved as:</div><div class="line"># /home/michaelx/AOSP_NBD91Z/hs_err_pid508.log</div><div class="line">[  5% 1883/35393] Docs droiddoc: out/target/common/docs/system-api-stubs</div><div class="line">DroidDoc took 27 sec. to write docs to out/target/common/docs/system-api-stubs</div><div class="line">ninja: build stopped: subcommand failed.</div><div class="line">make: *** [ninja_wrapper] Error 1</div></pre></td></tr></table></figure></p>
<p>解决内存不足的3个办法：</p>
<ol>
<li>增加机器内存</li>
<li>增加swap分区</li>
<li>修改prebuild/sdk/tools/jack-admin文件</li>
</ol>
<p>第一种方式就不说了，给机器加根内存条，壕专享。<br>第二种方式：增加swap分区：<a href="http://hancj.blog.51cto.com/89070/197915" target="_blank" rel="external">http://hancj.blog.51cto.com/89070/197915</a><br>第三种方式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"># 备份jack-admin</div><div class="line">$ cp prebuild/sdk/tools/jack-admin ~/Docments/jack-admin.original</div><div class="line"></div><div class="line"># 修改jack-admin文件</div><div class="line">$ vim prebuild/sdk/tools/jack-admin</div><div class="line"></div><div class="line"># start-server方法，笔者的jack-admin在443行，修改该方法中的一句话：</div><div class="line"># JACK_SERVER_COMMAND=&quot;java -Djava.io.tmpdir=$TMPDIR $JACK_SERVER_VM_ARGUMENTS -cp $LAUNCHER_JAR $LAUNCHER_NAME&quot;</div><div class="line"># 改成下面这行,增加java堆大小。</div><div class="line">JACK_SERVER_COMMAND=&quot;java -Djava.io.tmpdir=$TMPDIR $JACK_SERVER_VM_ARGUMENTS -Xmx8000M -cp $LAUNCHER_JAR $LAUNCHER_NAME&quot;</div></pre></td></tr></table></figure></p>
<blockquote>
<p>以上增加的-Xmx8000M，表示允许java在运行时java堆使用最大不超过8000M内存，这个数值是笔者经历了多次测试得到的结果，2048M，4096M，依旧没通过编译，改成8000M后编译通过，可能跟笔者自身硬件限制有很大关系</p>
</blockquote>
<pre><code>另一种修改方式：修改jack-admin第29行的变量：JACK_SERVER_VM_ARGUMENTS=&quot;${JACK_SERVER_VM_ARGUMENTS:=-Dfile.encoding-UTF-8 -XX:+TieredCompilation}&quot;
改成：
JACK_SERVER_VM_ARGUMENTS=&quot;${JACK_SERVER_VM_ARGUMENTS:=-Dfile.encoding-UTF-8 -XX:+TieredCompilation -Xmx8000M}&quot;
但是这种修改方式仍然不好使，编译失败了。
</code></pre><p>笔者是尝试了第二，三种方式解决。</p>
<p><strong>jack-server无法运行</strong><br>错误日志如下：<br><code>[ 37% 13421/35393] Ensure Jack server is installed and started
FAILED: /bin/bash -c &quot;(prebuilts/sdk/tools/jack-admin install-server prebuilts/sdk/tools/jack-launcher.jar prebuilts/sdk/tools/jack-server-4.8.ALPHA.jar  2&gt;&amp;1 || (exit 0) ) &amp;&amp; (JACK_SERVER_VM_ARGUMENTS=\&quot;-Dfile.encoding=UTF-8 -XX:+TieredCompilation\&quot; prebuilts/sdk/tools/jack-admin start-server 2&gt;&amp;1 || exit 0 ) &amp;&amp; (prebuilts/sdk/tools/jack-admin update server prebuilts/sdk/tools/jack-server-4.8.ALPHA.jar 4.8.ALPHA 2&gt;&amp;1 || exit 0 ) &amp;&amp; (prebuilts/sdk/tools/jack-admin update jack prebuilts/sdk/tools/jacks/jack-2.28.RELEASE.jar 2.28.RELEASE || exit 47; prebuilts/sdk/tools/jack-admin update jack prebuilts/sdk/tools/jacks/jack-3.36.CANDIDATE.jar 3.36.CANDIDATE || exit 47; prebuilts/sdk/tools/jack-admin update jack prebuilts/sdk/tools/jacks/jack-4.7.BETA.jar 4.7.BETA || exit 47 )&quot;
Jack server already installed in &quot;/home/michaelx/.jack-server&quot;
Launching Jack server java -XX:MaxJavaStackTraceDepth=0 -Djava.io.tmpdir=/tmp -Dfile.encoding=UTF-8 -XX:+TieredCompilation -cp /home/michaelx/.jack-server/launcher.jar com.android.jack.launcher.ServerLauncher
Jack server failed to (re)start, try &#39;jack-diagnose&#39; or see Jack server log
No Jack server running. Try &#39;jack-admin start-server&#39;
No Jack server running. Try &#39;jack-admin start-server&#39;
[ 37% 13421/35393] target thumb C++: libicui18n &lt;= external/icu/icu4c/source/i18n/coptccal.cpp
[ 37% 13421/35393] target thumb C++: libicui18n &lt;= external/icu/icu4c/source/i18n/compactdecimalformat.cpp
[ 37% 13421/35393] target thumb C++: libicui18n &lt;= external/icu/icu4c/source/i18n/cpdtrans.cpp
ninja: build stopped: subcommand failed.</code></p>
<p>解决Jack server failed to (re)start办法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ cd /prebuild/sdk/tools/</div><div class="line"></div><div class="line">$ jack-admin stop-server</div><div class="line">$ jack-admin start-server</div></pre></td></tr></table></figure>
<p>和各路编译错误大战了7天7夜（真的是7天7夜呀，碰到的无数问题我都没写完呢），终于修成正果。</p>
<hr>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>到了这里，相信大家都能轻松搞机了，如果有需要Nexus的刷机教程，请留言评论，下次出一篇Nexus的刷机过程。放2张Nexus 6刷机后的高清截图<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="http://img.blog.csdn.net/20170313115421821?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvWGlvbmdfSVQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="首屏截图" title="">
                </div>
                <div class="image-caption">首屏截图</div>
            </figure></p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="http://img.blog.csdn.net/20170313115511697?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvWGlvbmdfSVQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="抽屉截图" title="">
                </div>
                <div class="image-caption">抽屉截图</div>
            </figure>
<blockquote>
<p>本文原创作者:<a href="http://blog.csdn.net/xiong_it" target="_blank" rel="external">MichaelX</a>,博客地址:<a href="http://blog.csdn.net/xiong_it.转载请注明来源" target="_blank" rel="external">http://blog.csdn.net/xiong_it.转载请注明来源</a></p>
</blockquote>
<p>欢迎光临：<a href="https://xiong-it.github.io" target="_blank" rel="external">MichaelX’s Blog</a></p>
<h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p>感谢<br>AOSP官网：<a href="https://source.android.com/source/initializing.html" target="_blank" rel="external">https://source.android.com/source/initializing.html</a><br>AskUbuntu：<a href="http://askubuntu.com/questions/709904/ubuntu-openjdk-8-unable-to-locate-package" target="_blank" rel="external">http://askubuntu.com/questions/709904/ubuntu-openjdk-8-unable-to-locate-package</a><br>CSDN:<a href="http://blog.csdn.net/brightming/article/details/49763515" target="_blank" rel="external">http://blog.csdn.net/brightming/article/details/49763515</a></p>
<p>etc….</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;为你手中的Nexus,Pixel手机刷入自己的专属Rom&lt;br&gt;
    
    </summary>
    
      <category term="Android" scheme="http://blog.michaelx.tech/categories/Android/"/>
    
    
      <category term="Ubuntu" scheme="http://blog.michaelx.tech/tags/Ubuntu/"/>
    
      <category term="AOSP" scheme="http://blog.michaelx.tech/tags/AOSP/"/>
    
      <category term="Nexus" scheme="http://blog.michaelx.tech/tags/Nexus/"/>
    
      <category term="Pixel" scheme="http://blog.michaelx.tech/tags/Pixel/"/>
    
  </entry>
  
  <entry>
    <title>Android:BLE智能硬件开发详解</title>
    <link href="http://blog.michaelx.tech/2017-03/Android-BLE%E6%99%BA%E8%83%BD%E7%A1%AC%E4%BB%B6%E5%BC%80%E5%8F%91%E8%AF%A6%E8%A7%A3/"/>
    <id>http://blog.michaelx.tech/2017-03/Android-BLE智能硬件开发详解/</id>
    <published>2017-03-14T03:23:18.000Z</published>
    <updated>2017-05-03T08:21:21.752Z</updated>
    
    <content type="html"><![CDATA[<p>前些年，智能硬件炒的挺火的，那今天，咱就来说说<strong>智能硬件那些事</strong><br><a id="more"></a></p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><ul>
<li><strong>前言</strong></li>
<li><strong>BLE是个什么鬼</strong></li>
<li><strong>BLE中的角色分工</strong></li>
<li><strong>主要的关键词和概念</strong><ul>
<li>GATT(Generic Attribute Profile )</li>
<li>Characteristic</li>
<li>Service</li>
</ul>
</li>
<li><strong>Android如何使用BLE</strong><ul>
<li>蓝牙权限</li>
<li>APP和BLE外设交互流程</li>
</ul>
</li>
<li><strong>后记</strong><br><br></li>
</ul>
<blockquote>
<p>本文作者MichaelX，博客地址：<a href="http://blog.csdn.net/xiong_it" target="_blank" rel="external">http://blog.csdn.net/xiong_it</a> 转载请注明来源</p>
</blockquote>
<hr>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>前些年，智能硬件炒的挺火的，那今天，咱就来说说<strong>智能硬件那些事</strong>。BLE是智能硬件的一种通讯方式，通过BLE连接，iOS &amp; Android手机和智能硬件就可以进行自定义的交互了。交互的体验如何，很大程度上取决于智能硬件的驱动工程师驱动写的好不好，以及App的代码质量如何。</p>
<p>笔者曾参与过多款BLE智能硬件的开发，许久不用，怕忘了，把自己的整理的一些知识记录与此，同时也希望能够给一些同学带来帮助。本文将尽力向读者讲清楚BLE是什么，以及在实际Android开发中该如何使用BLE。</p>
<p><strong>前方高能：</strong>文章有点长，笔者经历了好几次改版，也花费了好几个月的业余时间，读者可能需要点耐心。着急的读者可直接跳转至<strong><a href="http://blog.csdn.net/Xiong_IT/article/details/60966458#t8" target="_blank" rel="external">Android如何使用BLE</a></strong></p>
<h1 id="BLE是个什么鬼"><a href="#BLE是个什么鬼" class="headerlink" title="BLE是个什么鬼"></a>BLE是个什么鬼</h1><p>BLE：Bluetooth Low Energy,低功耗蓝牙。Android官方介绍如下：</p>
<blockquote>
<p>Android 4.3 (API Level 18) introduces built-in platform support for Bluetooth Low Energy in the central role and provides APIs that apps can use to discover devices, query for services, and read/write characteristics. In contrast to Classic Bluetooth, Bluetooth Low Energy (BLE) is designed to provide significantly lower power consumption. This allows Android apps to communicate with BLE devices that have low power requirements, such as proximity sensors, heart rate monitors, fitness devices, and so on.</p>
</blockquote>
<p>什么意思呢？自从API18/Android4.3开始，Android开始支持低功耗蓝牙并给APP提供了一套api调用。相比传统蓝牙来说，BLE技术旨在降低蓝牙功耗。至于我们Android开发者来说，要做的就是调用这套api，和具备蓝牙的智能硬件沟通，通过蓝牙读写操控智能硬件。</p>
<p>BLE技术允许APP和那些有着<strong>低功耗</strong>需求的BLE设备进行通讯，这些设备包括但不限于：距离传感器设备，心跳率检测仪，健身器材，智能穿戴等。</p>
<blockquote>
<p><strong>约定:文中提到的”外设”,”BLE外设”和”智能硬件”是等价的.请读者知悉.</strong></p>
</blockquote>
<hr>
<h1 id="角色分工"><a href="#角色分工" class="headerlink" title="角色分工"></a>角色分工</h1><blockquote>
<p>Once the phone and the activity tracker have established a connection, they start transferring GATT metadata to one another. Depending on the kind of data they transfer, one or the other might act as the server. For example, if the activity tracker wants to report sensor data to the phone, it might make sense for the activity tracker to act as the server. If the activity tracker wants to receive updates from the phone, then it might make sense for the phone to act as the server.</p>
</blockquote>
<p>在Android APP和BLE外设进行交互时,他们分别扮演两个角色.这两个角色是不固定的.<br>GATT server:发送数据的一方.<br>GATT client:接收数据的一方.<br>当APP向外设写入数据时,APP就是server,外设就是client;当APP读取外设数据时,APP就是client.外设就是server.</p>
<hr>
<h1 id="主要的关键词和概念"><a href="#主要的关键词和概念" class="headerlink" title="主要的关键词和概念"></a>主要的关键词和概念</h1><h2 id="GATT-Generic-Attribute-Profile"><a href="#GATT-Generic-Attribute-Profile" class="headerlink" title="GATT(Generic Attribute Profile )"></a>GATT(Generic Attribute Profile )</h2><blockquote>
<p>The GATT profile is a general specification for sending and receiving short pieces of data known as “attributes” over a BLE link. All current Low Energy APPlication profiles are based on GATT.</p>
</blockquote>
<p>这个是BLE通讯的基本协议,这个协议定义了BLE发送和接收一小段数据的规范,这些被传输的小段数据被称为”attributes”.</p>
<h2 id="Characteristic"><a href="#Characteristic" class="headerlink" title="Characteristic"></a>Characteristic</h2><blockquote>
<p>A characteristic contains a single value and 0-n descriptors that describe the characteristic’s value. A characteristic can be thought of as a type, analogous to a class. </p>
</blockquote>
<p>博主的理解中,”Characteristic”是BLE通讯之间的沟通”搬运工”,因为这是我们从智能硬件直接读写的东西,它依附于下文的Service存在，有自己的标志码：uuid。它『<strong>分为读取BLE外设数据的Characteristic &amp; 向BLE外设写入数据的Characteristic</strong>』。<br>下面章节中将用代码说话.</p>
<h2 id="Service"><a href="#Service" class="headerlink" title="Service"></a>Service</h2><blockquote>
<p>A service is a collection of characteristics. For example, you could have a service called “Heart Rate Monitor” that includes characteristics such as “heart rate measurement.” </p>
</blockquote>
<p>此Service非彼Android四大组件中的彼Service,而是BluetoothGattService.这个Service是一个characteristics的集合,它可以理解为针对某个信号的通讯线路。</p>
<hr>
<h1 id="Android如何使用BLE"><a href="#Android如何使用BLE" class="headerlink" title="Android如何使用BLE"></a>Android如何使用BLE</h1><h2 id="蓝牙权限"><a href="#蓝牙权限" class="headerlink" title="蓝牙权限"></a>蓝牙权限</h2><p>使用BLE需要两个权限</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">"android.permission.BLUETOOTH"</span>/&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">"android.permission.BLUETOOTH_ADMIN"</span>/&gt;</span></div></pre></td></tr></table></figure>
<p>如果你想要APP只适配具备BLE的手机,那个可以再添加一个硬件权限特性<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">uses-feature</span> <span class="attr">android:name</span>=<span class="string">"android.hardware.bluetooth_le"</span> <span class="attr">android:required</span>=<span class="string">"true"</span>/&gt;</span></div></pre></td></tr></table></figure></p>
<hr>
<h2 id="APP和BLE外设交互流程"><a href="#APP和BLE外设交互流程" class="headerlink" title="APP和BLE外设交互流程"></a>APP和BLE外设交互流程</h2><p>APP和BLE外设交互的一个大概流程就是:</p>
<ol>
<li>BLE外设打开电源</li>
<li>APP初始化蓝牙</li>
<li>APP扫描周边BLE外设</li>
<li>APP连接到周边BLE外设</li>
<li>APP读写BLE外设</li>
<li>交互完成,APP向BLE外设写入关机/待机指令(可选)</li>
<li>BLE外设关机</li>
<li>APP关闭本地蓝牙连接</li>
</ol>
<p>以下将逐步利用代码进行讲解APP和BLE外设交互.</p>
<h2 id="初始化BLE"><a href="#初始化BLE" class="headerlink" title="初始化BLE"></a>初始化BLE</h2><p>Java代码判断当前手机是否支持BLE低功耗蓝牙<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 判断手机是否支持BLE</span></div><div class="line"><span class="keyword">if</span> (!getPackageManager().hasSystemFeature(PackageManager.FEATURE_BLUETOOTH_LE)) &#123;</div><div class="line">    Toast.makeText(<span class="keyword">this</span>, R.string.ble_not_supported, Toast.LENGTH_SHORT).show();</div><div class="line">    finish();<span class="comment">// 如果手机不支持BLE就关闭程序,仅供参考</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>初始化蓝牙管理者和适配器,这2个对象是ble通讯的基石.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 初始化蓝牙管理者和适配器,这2个对象是ble通讯的基石.</span></div><div class="line"><span class="keyword">private</span> BluetoothAdapter mBluetoothAdapter;</div><div class="line">...</div><div class="line"><span class="keyword">final</span> BluetoothManager bluetoothManager =</div><div class="line">        (BluetoothManager) getSystemService(Context.BLUETOOTH_SERVICE);</div><div class="line">mBluetoothAdapter = bluetoothManager.getAdapter();</div></pre></td></tr></table></figure></p>
<p>跳转到系统蓝牙设置界面<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> BluetoothAdapter mBluetoothAdapter;</div><div class="line">...</div><div class="line"><span class="comment">// 验证蓝牙是否已打开,如果没打开就提示用户跳转打开.</span></div><div class="line"><span class="keyword">if</span> (mBluetoothAdapter == <span class="keyword">null</span> || !mBluetoothAdapter.isEnabled()) &#123;</div><div class="line">    Intent enableBtIntent = <span class="keyword">new</span> Intent(BluetoothAdapter.ACTION_REQUEST_ENABLE);</div><div class="line">    startActivityForResult(enableBtIntent, REQUEST_ENABLE_BT);</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p><br></p>
<h2 id="APP扫描周边BLE外设"><a href="#APP扫描周边BLE外设" class="headerlink" title="APP扫描周边BLE外设"></a>APP扫描周边BLE外设</h2><p>需要实现一个BluetoothAdapter.LeScanCallback回调接口，得到扫描结果。该接口只有一个回调方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * @param device 被手机蓝牙扫描到的BLE外设实体对象</div><div class="line"> * @param rssi 大概就是表示BLE外设的信号强度，如果为0，则表示BLE外设不可连接。</div><div class="line"> * @param scanRecord 被扫描到的BLE外围设备提供的扫描记录，一般没什么用</div><div class="line"> */</div><div class="line">public void onLeScan(final BluetoothDevice device, int rssi, byte[] scanRecord)</div></pre></td></tr></table></figure></p>
<p>由于扫描BLE设备比较消耗资源，官方推荐间歇性扫描，示例代码如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line">    private BluetoothAdapter mBluetoothAdapter;</div><div class="line">    private boolean mScanning;</div><div class="line">    private Handler mHandler;</div><div class="line"></div><div class="line">    // 每扫描10s休息一下</div><div class="line">    private static final long SCAN_PERIOD = 10000;</div><div class="line">    </div><div class="line">    private BluetoothAdapter.LeScanCallback mLeScanCallback =</div><div class="line">        new BluetoothAdapter.LeScanCallback() &#123;</div><div class="line">    @Override</div><div class="line">    public void onLeScan(final BluetoothDevice device, int rssi, byte[] scanRecord) &#123;</div><div class="line">            // TODO 这里可以进行连接操作，连接操作见下一小节</div><div class="line">            if (device != null &amp;&amp; device.getName() != null &amp;&amp; device.getName().contain(&quot;你的产品名称&quot;))&#123;</div><div class="line">                // 连接设备</div><div class="line">                connectDevice(device);</div><div class="line">                // 停止扫描</div><div class="line">                scanLeDevice(false);</div><div class="line">            &#125;</div><div class="line">           &#125;</div><div class="line">       &#125;);</div><div class="line">   &#125;</div><div class="line">&#125;;</div><div class="line">    </div><div class="line">    ...</div><div class="line">    /**</div><div class="line">     * @param enable 是否进行扫描，false则停止扫描</div><div class="line">     */</div><div class="line">    private void scanLeDevice(final boolean enable) &#123;</div><div class="line">        if (enable) &#123;</div><div class="line">            // 利用Handler进行间歇性扫描，每次扫描时间：10s</div><div class="line">            mHandler.postDelayed(new Runnable() &#123;</div><div class="line">                @Override</div><div class="line">                public void run() &#123;</div><div class="line">                    mScanning = false;</div><div class="line">                    mBluetoothAdapter.stopLeScan(mLeScanCallback);</div><div class="line">                &#125;</div><div class="line">            &#125;, SCAN_PERIOD);</div><div class="line"></div><div class="line">            mScanning = true;</div><div class="line">            mBluetoothAdapter.startLeScan(mLeScanCallback);</div><div class="line">        &#125; else &#123;</div><div class="line">            // 停止扫描</div><div class="line">            mScanning = false;</div><div class="line">            mBluetoothAdapter.stopLeScan(mLeScanCallback);</div><div class="line">        &#125;</div><div class="line">        ...</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p><br></p>
<h2 id="APP连接周边BLE外设"><a href="#APP连接周边BLE外设" class="headerlink" title="APP连接周边BLE外设"></a>APP连接周边BLE外设</h2><p>连接操作是进行手机和BLE外设交互的基础，请看下面connectDevice(BluetoothDevice)方法实现。</p>
<p>分两步走：</p>
<ol>
<li>判断该设备是否连接过，连接过则首先尝试直接连接：BluetoothGatt.connect()</li>
<li>首次连接或者直连失败使用：BluetoothDevice.connectGatt(Context context, boolean autoConnect, BluetoothGattCallback callback)<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">connectDevice</span><span class="params">(<span class="keyword">final</span> BluetoothDevice device)</span> </span>&#123;</div><div class="line">		<span class="keyword">if</span> (mBluetoothAdapter == <span class="keyword">null</span> || device == <span class="keyword">null</span>) &#123;</div><div class="line">			Log.w(TAG,</div><div class="line">					<span class="string">"BluetoothAdapter not initialized or unspecified address."</span>);</div><div class="line">			<span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">		&#125;</div><div class="line">        </div><div class="line">        String address = device.getAddress();</div><div class="line">		<span class="comment">// 之前连接过的设备，尝试直接连接。mBluetoothDeviceAddress表示刚才连接过的设备地址</span></div><div class="line">		<span class="keyword">if</span> (mBluetoothDeviceAddress != <span class="keyword">null</span></div><div class="line">				&amp;&amp; address.equals(mBluetoothDeviceAddress)</div><div class="line">				&amp;&amp; mBluetoothGatt != <span class="keyword">null</span>) &#123;</div><div class="line">			Log.d(TAG,</div><div class="line">					<span class="string">"Trying to use an existing mBluetoothGatt for connection."</span>);</div><div class="line">			<span class="keyword">if</span> (mBluetoothGatt.connect()) &#123;<span class="comment">// 连接成功</span></div><div class="line">			    <span class="comment">// 修改连接状态变量</span></div><div class="line">				mConnectionState = STATE_CONNECTING;</div><div class="line">				<span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">			&#125; <span class="keyword">else</span> &#123;</div><div class="line">				<span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		<span class="keyword">final</span> BluetoothDevice remoteDevice = mBluetoothAdapter.getRemoteDevice(address);</div><div class="line">		<span class="keyword">if</span> (remoteDevice == <span class="keyword">null</span>) &#123;</div><div class="line">			Log.w(TAG, <span class="string">"Device not found.  Unable to connect."</span>);</div><div class="line">			<span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">		&#125;</div><div class="line">		mBluetoothGatt = remoteDevice.connectGatt(context, <span class="keyword">false</span>, mGattCallback);</div><div class="line">		Log.d(TAG, <span class="string">"Trying to create a new connection."</span>);</div><div class="line">		<span class="comment">// 将当前连接上的设备地址赋值给连接过的设备地址变量</span></div><div class="line">		mBluetoothDeviceAddress = address;</div><div class="line">		<span class="comment">// 改变连接状态变量</span></div><div class="line">		mConnectionState = STATE_CONNECTING;</div><div class="line">		<span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<p>连接BEL外设时，需要一个实现回调接口以得到连接状态，BluetoothGattCallback大概实现如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div></pre></td><td class="code"><pre><div class="line">private final BluetoothGattCallback mGattCallback =</div><div class="line">            new BluetoothGattCallback() &#123;</div><div class="line">        @Override</div><div class="line">        public void onConnectionStateChange(BluetoothGatt gatt, int status, int newState) &#123;</div><div class="line">            // 该方法在连接状态改变时回调，newState即代表当前连接状态</div><div class="line">            String intentAction;</div><div class="line">            // 连接上了</div><div class="line">            if (newState == BluetoothProfile.STATE_CONNECTED) &#123;</div><div class="line">                intentAction = ACTION_GATT_CONNECTED;</div><div class="line">                // 改变蓝牙连接状态变量</div><div class="line">                mConnectionState = STATE_CONNECTED;</div><div class="line">                // 发送自定义广播：连接上了</div><div class="line">                broadcastUpdate(intentAction);</div><div class="line">                // 当前外设相当于前面章节提到的Server角色：提供数据被手机读取</div><div class="line">                Log.i(TAG, &quot;Connected to GATT server.&quot;);</div><div class="line">                // 获取读/写服务：Service。该方法会触发下面的onServicesDiscovered()回调</div><div class="line">                mBluetoothGatt.discoverServices();</div><div class="line"></div><div class="line">            &#125; else if (newState == BluetoothProfile.STATE_DISCONNECTED) &#123;// 断开连接了</div><div class="line">                intentAction = ACTION_GATT_DISCONNECTED;</div><div class="line">                mConnectionState = STATE_DISCONNECTED;</div><div class="line">                Log.i(TAG, &quot;Disconnected from GATT server.&quot;);</div><div class="line">                // 发送自定义广播：断开了连接</div><div class="line">                broadcastUpdate(intentAction);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        @Override</div><div class="line">        // 该方法在蓝牙服务被发现时回调。由上述的mBluetoothGatt.discoverServices()触发结果。</div><div class="line">        public void onServicesDiscovered(BluetoothGatt gatt, int status) &#123;</div><div class="line">            // 发现服务。status表示发现服务的结果码</div><div class="line">            if (status == BluetoothGatt.GATT_SUCCESS) &#123;</div><div class="line">                broadcastUpdate(ACTION_GATT_SERVICES_DISCOVERED);</div><div class="line">                // TODO 从发现的Service来找出读数据用的BluetoothGattCharacteristic和写数据用的BluetoothGattCharacteristic。</div><div class="line">                initReadAndWriteCharacteristic(gatt.getServices());</div><div class="line">                </div><div class="line">            &#125; else &#123;// 未发现服务</div><div class="line">                Log.w(TAG, &quot;onServicesDiscovered received: &quot; + status);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        @Override</div><div class="line">        // 读取操作的回调结果</div><div class="line">        public void onCharacteristicRead(BluetoothGatt gatt, BluetoothGattCharacteristic characteristic, int status) &#123;</div><div class="line">            if (status == BluetoothGatt.GATT_SUCCESS) &#123;</div><div class="line">                broadcastUpdate(ACTION_DATA_AVAILABLE, characteristic);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        @Override</div><div class="line">        // 写入操作的回调结果</div><div class="line">        public void onCharacteristicWrite(BluetoothGatt gatt,</div><div class="line">				BluetoothGattCharacteristic characteristic, int status) &#123;</div><div class="line">		&#125;;</div><div class="line">     ...</div><div class="line">    &#125;;</div><div class="line">...</div></pre></td></tr></table></figure></p>
<p><br><br><strong>找出读写”数据包”的”搬运工”</strong></p>
<p>下面是找出读写”搬运工”BluetoothGattCharacteristic的initReadAndWriteCharacteristic()代码实现</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">BluetoothGattCharacteristic mReadCharacteristic;</div><div class="line">BluetoothGattCharacteristic mWriteCharacteristic;</div><div class="line"></div><div class="line">public void initReadAndWriteCharacteristic(</div><div class="line">			List&lt;BluetoothGattService&gt; gattServices) &#123;</div><div class="line">		if (gattServices == null)</div><div class="line">			return;</div><div class="line">		// 遍历所有的 GATT Services.</div><div class="line">		for (BluetoothGattService gattService : gattServices) &#123;</div><div class="line">			if (!gattService.getUuid().toString().trim().equalsIgnoreCase(&quot;这里是你期望的Service的uuid，由你司智能外色的驱动工程师决定&quot;))</div><div class="line">			    continue;</div><div class="line">			List&lt;BluetoothGattCharacteristic&gt; gattCharacteristics = gattService.getCharacteristics();</div><div class="line">			// 遍历当前Service中所有的Characteristics.</div><div class="line">			for (BluetoothGattCharacteristic gattCharacteristic : gattCharacteristics) &#123;</div><div class="line"></div><div class="line">				if (gattCharacteristic.getUuid().toString().trim().equalsIgnoreCase(&quot;&quot;这里是你期望的写数据的uuid，由你司驱动工程师决定&quot;&quot;)) &#123;</div><div class="line">					mWriteCharacteristic = gattCharacteristic;</div><div class="line">				&#125; else if (gattCharacteristic.getUuid().toString().trim().equalsIgnoreCase(&quot;这里是你期望的读数据的uuid，由你司驱动工程师决定&quot;)) &#123;</div><div class="line">					mReadCharacteristic = gattCharacteristic;</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
<p>至此，我们就拿到了可携带读写数据的“搬运工”-『<strong>mReadCharacteristic  &amp; mWriteCharacteristic</strong>』，下面就可以和智能硬件进行交互了。<br><br></p>
<h2 id="APP读取BLE外设蓝牙数据"><a href="#APP读取BLE外设蓝牙数据" class="headerlink" title="APP读取BLE外设蓝牙数据"></a>APP读取BLE外设蓝牙数据</h2><p>想要读取BLE外设的数据时，比如：心跳速率，电量等等。可通过下面方式。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">// 告诉”搬运工“我想知道BLE外设当前数据,将回调BluetoothGattCallback接口的onCharacteristicRead()方法</div><div class="line">mBluetoothGatt.readCharacteristic(mReadCharacteristic);</div><div class="line"></div><div class="line">// 读取BLE蓝牙数据操作的回调方法</div><div class="line"> @Override</div><div class="line">public void onCharacteristicRead(BluetoothGatt gatt, BluetoothGattCharacteristic characteristic, int status) &#123;</div><div class="line">            if (status == BluetoothGatt.GATT_SUCCESS) &#123;</div><div class="line">                broadcastUpdate(ACTION_DATA_AVAILABLE, characteristic);</div><div class="line">                // ”搬运工“把”数据包“搬出来了</div><div class="line">                byte[] data = characteristic.getValue();</div><div class="line">		        // 根据驱动工程师给的协议文档，解析该数组，该处假设数组0位上表示心跳速率</div><div class="line">		        int heartRateR = data[0];// 得到心跳速率，做相应UI更新和操作</div><div class="line">		&#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div></pre></td></tr></table></figure></p>
<p><br></p>
<h2 id="APP向BLE外设写入数据"><a href="#APP向BLE外设写入数据" class="headerlink" title="APP向BLE外设写入数据"></a>APP向BLE外设写入数据</h2><p>比如说你想告诉BLE外设让他锁屏，或者进行某个动作，APP向操纵BLE外设时可通过以下方式<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">// 根据驱动工程师给的协议文档，组织一个数组命令</div><div class="line">byte[] data = getData();</div><div class="line">// 将该条命令“数据包”给“搬运工&quot;</div><div class="line">mWriteCharacteristic.setValue(data);</div><div class="line"></div><div class="line">// ”搬运工“将数据搬到BLE外设里面了，将回调BluetoothGattCallback接口的onCharacteristicWrite()方法</div><div class="line">mBluetoothGatt.writeCharacteristic(characteristic);</div><div class="line"></div><div class="line">// 向BLE蓝牙外设写入数据操作的回调方法</div><div class="line">@Override</div><div class="line">public void onCharacteristicWrite(BluetoothGatt gatt, BluetoothGattCharacteristic characteristic, int status) &#123;</div><div class="line">			if(status == BluetoothGatt.GATT_SUCCESS) &#123;</div><div class="line">			    // 命令写入成功，数据包成功写入BLE外设中</div><div class="line">			&#125;	</div><div class="line">		&#125;;</div></pre></td></tr></table></figure></p>
<blockquote>
<p>多说一句，其实，手机关闭外设也是一条写入命令，外设得到该命令后即进入省电待机状态，一般外设也可以通过开/关机键彻底关机。</p>
</blockquote>
<p><br></p>
<h2 id="APP关闭蓝牙连接"><a href="#APP关闭蓝牙连接" class="headerlink" title="APP关闭蓝牙连接"></a>APP关闭蓝牙连接</h2><p>交互完了，不需要了，还是把APP蓝牙连接给断掉吧<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public void close() &#123;</div><div class="line">    if (mBluetoothGatt == null) &#123;</div><div class="line">        return;</div><div class="line">    &#125;</div><div class="line">    mBluetoothGatt.close();</div><div class="line">    mBluetoothGatt = null;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<hr>
<h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>Android官方在SDK中提供了许多demo供开发者参考（1年前左右），其实关于BLE api调用也是有的,不过只涉及了蓝牙外设的连接,未涉及蓝牙数据读写.BLE官方demo路径:<code>User/AndroidSDK/samples/android-19/connectivity/BluetoothLeGatt</code><br>以上路径是笔者举例的路径,如果你的SDK目录下没有samples目录，现在（20170308）SDK Manager已经不开放sample下载了,请点击下载：<a href="https://pan.baidu.com/s/1o87ASJK" target="_blank" rel="external">android-sample-api19</a> 文件提取密码: y87g</p>
<blockquote>
<p>本文原创作者:<a href="http://blog.csdn.net/xiong_it" target="_blank" rel="external">MichaelX</a>,博客地址:<a href="http://blog.csdn.net/xiong_it.转载请注明来源" target="_blank" rel="external">http://blog.csdn.net/xiong_it.转载请注明来源</a></p>
</blockquote>
<p>欢迎光临：<a href="https://xiong-it.github.io" target="_blank" rel="external">MichaelX’s Blog</a></p>
<h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="https://developer.android.com/guide/topics/connectivity/bluetooth-le.html#terms" target="_blank" rel="external">https://developer.android.com/guide/topics/connectivity/bluetooth-le.html#terms</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前些年，智能硬件炒的挺火的，那今天，咱就来说说&lt;strong&gt;智能硬件那些事&lt;/strong&gt;&lt;br&gt;
    
    </summary>
    
      <category term="Android" scheme="http://blog.michaelx.tech/categories/Android/"/>
    
    
      <category term="BLE" scheme="http://blog.michaelx.tech/tags/BLE/"/>
    
      <category term="智能硬件" scheme="http://blog.michaelx.tech/tags/%E6%99%BA%E8%83%BD%E7%A1%AC%E4%BB%B6/"/>
    
      <category term="Android" scheme="http://blog.michaelx.tech/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Design Patterns in Android：模板方法模式</title>
    <link href="http://blog.michaelx.tech/2017-02/Design-Patterns-in-Android%EF%BC%9A%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/"/>
    <id>http://blog.michaelx.tech/2017-02/Design-Patterns-in-Android：模板方法模式/</id>
    <published>2017-02-10T17:16:27.000Z</published>
    <updated>2017-05-03T08:21:21.752Z</updated>
    
    <content type="html"><![CDATA[<p>今天给大家分享的是《设计模式Android篇：模板方法模式》。<br>其实有一定开发经验的小伙伴已经不自觉的使用了模板方法了，今天将通过Android源码和Android开发案例跟大家讲解什么是模板方法模式。<br><a id="more"></a></p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>今天给大家分享的是《设计模式Android篇：模板方法模式》。<br>其实有一定开发经验的小伙伴已经不自觉的使用了模板方法了，今天将通过Android源码和Android开发案例跟大家讲解什么是模板方法模式。<br>点击此处查看<a href="http://blog.csdn.net/xiong_it/article/details/54574020" target="_blank" rel="external">《Design Patterns in Android》</a>系列其他文章。</p>
<pre><code>本文原创作者MichaelX（xiong_it），博客链接：http://blog.csdn.net/xiong_it，转载请注明出处。
</code></pre><h1 id="模板方式模式定义"><a href="#模板方式模式定义" class="headerlink" title="模板方式模式定义"></a>模板方式模式定义</h1><blockquote>
<p>模板方法模式(Template method pattern):定义一个操作中的算法框架，而将一些步骤延迟到子类中实现，使得子类可以不改变算法结构即可重新定义该算法的某些特定步骤</p>
</blockquote>
<p>以上定义有两个关键词</p>
<ol>
<li>算法框架：其本质是一个方法，也就是模板方法，它的调用会依次执行一些特定的步骤</li>
<li>特定步骤：其本质一系列抽象的方法，交由子类实现，以重新定义该算法细节</li>
</ol>
<h1 id="模板方法的UML类图"><a href="#模板方法的UML类图" class="headerlink" title="模板方法的UML类图"></a>模板方法的UML类图</h1><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="http://img.blog.csdn.net/20170209003325599?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvWGlvbmdfSVQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="模板方法的UML类图" title="">
                </div>
                <div class="image-caption">模板方法的UML类图</div>
            </figure>
<p>templateMethod：模板方法<br>methodA,methodB：特定步骤</p>
<h1 id="模板方法示例代码"><a href="#模板方法示例代码" class="headerlink" title="模板方法示例代码"></a>模板方法示例代码</h1><p>基类<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">public abstract class AbstractClass &#123;</div><div class="line"></div><div class="line">	public void templateMethod() &#123;</div><div class="line">		methodA();</div><div class="line"></div><div class="line">		methodB();</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	protected void abstract methodA();</div><div class="line"></div><div class="line">	protected void abstract methodB();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>子类<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">public class ConcreteClassA extends AbstractClass &#123;</div><div class="line"></div><div class="line"></div><div class="line">	@Override</div><div class="line">	protected void abstract methodA() &#123;</div><div class="line">		System.out.println(&quot;ConcreteClassA.do something.&quot;);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	protected void abstract methodB() &#123;</div><div class="line">		System.out.println(&quot;ConcreteClassA.do other thing.&quot;);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">public class ConcreteClassB extends AbstractClass &#123;</div><div class="line"></div><div class="line"></div><div class="line">	@Override</div><div class="line">	protected void abstract methodA() &#123;</div><div class="line">		System.out.println(&quot;ConcreteClassB.do something.&quot;);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	protected void abstract methodB() &#123;</div><div class="line">		System.out.println(&quot;ConcreteClassB.do other thing.&quot;);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1 id="Android源码中模板方法模式"><a href="#Android源码中模板方法模式" class="headerlink" title="Android源码中模板方法模式"></a>Android源码中模板方法模式</h1><p>在Android的api源码中，给我们提供了一个执行异步任务的类AsyncTask，其用法d大致如下</p>
<ol>
<li>写一个自己的异步任务类（比如叫DownloadTask）继承自AsyncTask，主要复写onPreExecute(),doInBackground(),onPostExecute()等。</li>
<li>执行downloadTask</li>
</ol>
<p>代码如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">new DownloadTask().execute(url);</div></pre></td></tr></table></figure>
<p>我们发现只要调用了execute（Params…）后，AsyncTask自动调用了各个回调方法了，onPreExecute(),doInBackground(),onPostExecute()等，其实这就是<strong>模板方法模式</strong>！下面我们通过一个android开发案例来弄懂模板方法。</p>
<h1 id="Android开发中的模板方式模式实践"><a href="#Android开发中的模板方式模式实践" class="headerlink" title="Android开发中的模板方式模式实践"></a>Android开发中的模板方式模式实践</h1><p>Activity作为四大组件之首，是我们经常要使用到的，除非你的app不用和用户进行UI交互。<br>那在多个Activity中，我们通常在onCreate()做一些程序化的事情</p>
<ul>
<li>初始化控件</li>
<li>获取网络/数据库数据</li>
<li>注册事件监听</li>
<li>注册广播</li>
<li>等等</li>
</ul>
<p>在onDestroy()中</p>
<ul>
<li>反注册广播</li>
<li>资源释放等</li>
</ul>
<p>这时我们通常可以使用模板方法模式来抽象出一个BaseActityBaseFragment类似，不展开分析。实例代码如下</p>
<p>先写一个基类BaseActity<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div></pre></td><td class="code"><pre><div class="line">public abstract class BaseActivity extends Activity &#123;</div><div class="line">	@Override</div><div class="line">	public void onCreate(Bundle savedInstanceState) &#123;</div><div class="line">		super.onCreate(savedInstanceState);</div><div class="line"></div><div class="line">		initView();</div><div class="line"></div><div class="line">		initData();</div><div class="line"></div><div class="line">		initEvent();</div><div class="line"></div><div class="line">		registerBroadcast();</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	/**</div><div class="line">     * 初始化视图控件</div><div class="line">     */</div><div class="line">	protected abstract void initView();</div><div class="line"></div><div class="line">	/**</div><div class="line">     * 初始化数据</div><div class="line">     */</div><div class="line">	protected abstract void initData();</div><div class="line"></div><div class="line">	/**</div><div class="line">     * 初始化点击长按等事件</div><div class="line">     */</div><div class="line">	protected abstract void initEvent();</div><div class="line"></div><div class="line">	/**</div><div class="line">     * 注册广播接收者</div><div class="line">     */</div><div class="line">	protected void registerBroadcast() &#123;</div><div class="line">		// 子类可以选择性复写</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	public void onDestroy() &#123;</div><div class="line">		super.onDestroy();</div><div class="line"></div><div class="line">		unRegisterBroadcast();</div><div class="line"></div><div class="line">		releaseMemory();</div><div class="line">	&#125;</div><div class="line">	/**</div><div class="line">     * 注销广播接收者</div><div class="line">     */</div><div class="line">	protected void unRegisterBroadcast() &#123;</div><div class="line">		// 子类可以选择性复写</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	/**</div><div class="line">     * 做些释放对象引用等其他操作以释放内存</div><div class="line">     */</div><div class="line">	protected abstract void releaseMemory();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>随手写一个实现类MyActivity</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">public class MyActivity extends BaseActivity &#123;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	protected void initView() &#123;</div><div class="line">		setContentView(resId);</div><div class="line">		// TODO findViewById();</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	protected void initData() &#123;</div><div class="line">		// TODO 访问数据库/网络获取数据</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	protected void initEvent() &#123;</div><div class="line">		// TODO setOnClickListener</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	protected void releaseMemory() &#123;</div><div class="line">		// TODO 把一些手动释放的对象值设为null</div><div class="line">		someObj = null;// and so on.</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果再有一个其他Activity代码也是如此编写，以BaseActivity的onCreate(),onDestroy()为模板方法（算法框架），initView(),initData(),initEvent()等方法为特定步骤，利用模板方法构建了一个较好的基类，子类无需修改BaseActivity的算法框架，不同的Activity只需复写这些特定步骤即重新定义这些特定的细节步骤。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>看完这篇《Design Patterns in Android：策略模式》，是不是很多人恍然大悟，原来模板方法就是这样啊！<br>当编写一个方法时，其中包含了某些特定的步骤时，就可以考虑使用模板方法模式了。</p>
<p>好了，今天的《设计模式Android篇：策略模式》就到这里，请继续关注<a href="http://blog.csdn.net/xiong_it/article/details/54574020" target="_blank" rel="external">《Design Patterns in Android》（设计模式Android篇）</a>系列博文，欢迎各位读者朋友评论区拍砖交流，共同进步。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天给大家分享的是《设计模式Android篇：模板方法模式》。&lt;br&gt;其实有一定开发经验的小伙伴已经不自觉的使用了模板方法了，今天将通过Android源码和Android开发案例跟大家讲解什么是模板方法模式。&lt;br&gt;
    
    </summary>
    
      <category term="Design Pattern" scheme="http://blog.michaelx.tech/categories/Design-Pattern/"/>
    
    
      <category term="Android" scheme="http://blog.michaelx.tech/tags/Android/"/>
    
      <category term="设计模式" scheme="http://blog.michaelx.tech/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="Design Pattern" scheme="http://blog.michaelx.tech/tags/Design-Pattern/"/>
    
      <category term="模板方法模式" scheme="http://blog.michaelx.tech/tags/%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="Template Method" scheme="http://blog.michaelx.tech/tags/Template-Method/"/>
    
  </entry>
  
  <entry>
    <title>Design Patterns in Android：策略模式</title>
    <link href="http://blog.michaelx.tech/2017-02/Design-Patterns-in-Android%EF%BC%9A%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/"/>
    <id>http://blog.michaelx.tech/2017-02/Design-Patterns-in-Android：策略模式/</id>
    <published>2017-02-07T03:39:33.000Z</published>
    <updated>2017-05-03T08:21:21.752Z</updated>
    
    <content type="html"><![CDATA[<p>刚过去的春节，大家有没有从“节后综合征”中痊愈满血呢？ 新年里给大家带来的第一篇是《设计模式Android篇：策略模式》。 本文将通俗易懂的给大家分享Android源码中的策略模式和如何在开发中实践策略模式。<br><a id="more"></a></p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>刚过去的春节，大家有没有从“节后综合征”中痊愈满血呢？<br>新年里给大家带来的第一篇是《设计模式Android篇：策略模式》。<br>点击此处查看<a href="http://blog.csdn.net/xiong_it/article/details/54574020" target="_blank" rel="external">《Design Patterns in Android》</a>系列其他文章。</p>
<pre><code>本文原创作者MichaelX（xiong_it），博客链接：http://blog.csdn.net/xiong_it，转载请注明出处。
</code></pre><h2 id="策略模式定义"><a href="#策略模式定义" class="headerlink" title="策略模式定义"></a>策略模式定义</h2><blockquote>
<p>策略模式(Strategy pattern)：定义一组算法，将其各个封装，并且使他们有交换性。</p>
</blockquote>
<p>策略模式好处在于使得算法在用户使用的时候能独立的改变，单一的修改，并且有良好扩展性。</p>
<pre><code>算法：指的是各个策略的实现逻辑，而非算法领域的数据算法。
</code></pre><h2 id="策略模式UML类图"><a href="#策略模式UML类图" class="headerlink" title="策略模式UML类图"></a>策略模式UML类图</h2><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="http://img.blog.csdn.net/20170206191558604?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvWGlvbmdfSVQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="策略模式UML类图" title="">
                </div>
                <div class="image-caption">策略模式UML类图</div>
            </figure>
<p><strong>策略模式各角色讲解</strong></p>
<ul>
<li>IStrategy：策略基类（接口或者抽象类），定义子策略需要实现的方法，比如excute()，该方法取决于客户端代码（高层代码）需要该策略实现什么功能，子类则实现该方法，封装自己的算法，供外部调用。</li>
<li>Context：此Context，非彼（Android中的）Context，它持有IStrategy真实的实例对象，提供给客户端调用IStrategy时的上下文调度者。</li>
<li>ConcreteStrategyA：实现父类IStrategy的方法，封装自身算法逻辑。</li>
<li>ConcreteStrategyB：同上</li>
</ul>
<h2 id="策略模式的示例代码"><a href="#策略模式的示例代码" class="headerlink" title="策略模式的示例代码"></a>策略模式的示例代码</h2><p>IStrategy<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IStrategy</span> </span>&#123;</div><div class="line">	<span class="function"><span class="keyword">void</span> <span class="title">excute</span><span class="params">()</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>ConcreteStrategyA<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteStrategyA</span> <span class="keyword">implements</span> <span class="title">IStrategy</span></span>&#123;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">excute</span><span class="params">()</span> </span>&#123;</div><div class="line">		System.out.println(<span class="string">"1.我是ConcreteStrategyA的算法实现"</span>);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>ConcreteStrategyB</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteStrategyB</span> <span class="keyword">implements</span> <span class="title">IStrategy</span></span>&#123;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">excute</span><span class="params">()</span> </span>&#123;</div><div class="line">		System.out.println(<span class="string">"2.我是ConcreteStrategyB的算法实现"</span>);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Context上下文角色<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Context</span> </span>&#123;</div><div class="line">	<span class="keyword">private</span> IStrategy strategy;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Context</span><span class="params">(Strategy strategy)</span> </span>&#123;</div><div class="line">		<span class="keyword">this</span>.strategy = strategy;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">excute</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="keyword">this</span>.strategy.excute();</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>好了，下面是就是客户端代码，描述了如何使用策略模式<br>Client</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">		Context context;</div><div class="line"></div><div class="line">		context = <span class="keyword">new</span> Context(<span class="keyword">new</span> ConcreteStrategyA());</div><div class="line">		context.excute();</div><div class="line"></div><div class="line">		<span class="comment">// context = new Context(new ConcreteStrategyB());</span></div><div class="line">		<span class="comment">// context.excute();</span></div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如上，客户端需要什么策略就new什么策略，完全取决于客户端需求，而且如果策略A出现问题，修改策略A就是了，和其他地方完全无关，如果现有策略不符合需求，再实现一个ConcreteStrategyA即可。</p>
<h2 id="Android源码中的策略模式"><a href="#Android源码中的策略模式" class="headerlink" title="Android源码中的策略模式"></a>Android源码中的策略模式</h2><p><strong>大家在使用<a href="https://developer.android.com/guide/topics/graphics/view-animation.html" target="_blank" rel="external">Animation</a>动画时，可以给Animation对象设置不同的插值器（Interpolator）来实现动画快慢速度动态效果。</strong></p>
<p>比如：<br>LinearInterpolator，线性插值器，实现匀速动画<br>AccelerateDecelerateInterpolator：加速减速插值器，实现开始加速，结尾时减速的动画</p>
<p>BaseInterpolator类：Interpolator的实现类，就是速度插值器策略的基类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * An abstract class which is extended by default interpolators.</div><div class="line"> */</div><div class="line"><span class="keyword">abstract</span> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseInterpolator</span> <span class="keyword">implements</span> <span class="title">Interpolator</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> mChangingConfiguration;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * <span class="doctag">@hide</span></div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getChangingConfiguration</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> mChangingConfiguration;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * <span class="doctag">@hide</span></div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setChangingConfiguration</span><span class="params">(<span class="keyword">int</span> changingConfiguration)</span> </span>&#123;</div><div class="line">        mChangingConfiguration = changingConfiguration;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>Animation：Context上下文角色<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">public abstract class Animation implements Cloneable &#123;</div><div class="line">	// ...</div><div class="line">	// 省略无关代码</div><div class="line">	// ...</div><div class="line">	private Interpolator mInterpolator;</div><div class="line">	/**</div><div class="line">     * Sets the acceleration curve for this animation. Defaults to a linear</div><div class="line">     * interpolation.</div><div class="line">     *</div><div class="line">     * @param i The interpolator which defines the acceleration curve</div><div class="line">     * @attr ref android.R.styleable#Animation_interpolator</div><div class="line">     */</div><div class="line">    public void setInterpolator(Interpolator i) &#123;</div><div class="line">        mInterpolator = i;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>LinearInterpolator等子类就实现了各自速度快慢的算法逻辑<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">@HasNativeInterpolator</div><div class="line">public class LinearInterpolator extends BaseInterpolator &#123;</div><div class="line"></div><div class="line">    public LinearInterpolator() &#123;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public LinearInterpolator(Context context, AttributeSet attrs) &#123;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public float getInterpolation(float input) &#123;</div><div class="line">        return input;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>现在，我们给一个ImageView添加View动画</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">ImageView view;</div><div class="line">Animation animation = getResources().getAnimation(R.anim.pop_anim);</div><div class="line">// 给view的动画设置一个插值器策略</div><div class="line">animation.setInterpolator(new LinearInterpolator());</div><div class="line">view.startAnimation(animation);</div></pre></td></tr></table></figure>
<h2 id="Android开发中的策略模式实践"><a href="#Android开发中的策略模式实践" class="headerlink" title="Android开发中的策略模式实践"></a>Android开发中的策略模式实践</h2><p>需求，现在你开发的Android app需要实现盈利，PM经过一番规划，想要你接入<a href="http://blog.csdn.net/xiong_it/article/details/51685033" target="_blank" rel="external">微信支付</a>，<a href="http://blog.csdn.net/xiong_it/article/details/51819559" target="_blank" rel="external">支付宝支付</a>，银联支付等移动端通用支付方式。</p>
<p>这个功能好实现，接入相关支付SDK即可，问题就在如何优雅的实现这个功能呢？</p>
<blockquote>
<p>延伸阅读：<br><a href="http://blog.csdn.net/xiong_it/article/details/51685033" target="_blank" rel="external">《 Android App支付系列（一）：微信支付接入详细指南(附官方支付demo)》</a><br><a href="http://blog.csdn.net/xiong_it/article/details/51819559" target="_blank" rel="external">《 Android App支付系列（二）：支付宝SDK接入详细指南(附官方支付demo)》</a></p>
</blockquote>
<p>以下是笔者是实现，供各位读者参考。</p>
<ul>
<li>PayActivity：客户端角色，支付方式选择界面</li>
<li>AbsPayStrategy：作为支付策略基类，定义了一个pay方法</li>
<li>PayContext：上下文角色，用来封装支付AbsPayStrategy对象</li>
<li>WeChatPayStrategy：封装了微信支付算法逻辑</li>
<li>ALiPayStrategy：封装了支付宝支付算法逻辑</li>
<li>BankCardPayStrategy：封装了银行卡支付算法逻辑</li>
</ul>
<p><strong>支付功能的示意代码</strong><br>AbsPayStrategy的实际实现应该为抽象类，它需要持有Activity对象。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AbsPayStrategy</span> </span>&#123;</div><div class="line">	<span class="comment">// private Activity mActivity;</span></div><div class="line">	<span class="comment">// 本策略主要就是实现支付功能</span></div><div class="line">	<span class="function"><span class="keyword">void</span> <span class="title">pay</span><span class="params">()</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>Context上下文角色<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PayContext</span> </span>&#123;</div><div class="line">	<span class="keyword">private</span> AbsPayStrategy mPayStrategy;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="title">PayContext</span><span class="params">(AbsPayStrategy payStrategy)</span> </span>&#123;</div><div class="line">		mPayStrategy = payStrategy;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pay</span><span class="params">()</span> </span>&#123;</div><div class="line">		mPayStrategy.pay();</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>微信支付策略实现<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 微信支付策略</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WeChatPayStrategy</span> <span class="keyword">implements</span> <span class="title">AbsPayStrategy</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pay</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="comment">// 此处封装微信支付逻辑</span></div><div class="line">		<span class="comment">// 具体请参考笔者的博文《 Android App支付系列（一）：微信支付接入详细指南(附官方支付demo)》</span></div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>支付宝支付策略实现 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * 支付宝支付策略</div><div class="line"> */</div><div class="line">public class ALiPayStrategy  implements AbsPayStrategy &#123;</div><div class="line"></div><div class="line">	public void pay() &#123;</div><div class="line">		// 此处封装支付宝支付逻辑</div><div class="line">		// 具体请参考笔者的博文《 Android App支付系列（二）：支付宝支付SDk接入详细指南(附官方支付demo)》</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>具体的客户端代码，此处为PayActivity</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">public class PayActivity extends Activity implements View.OnclickListener&#123;</div><div class="line"></div><div class="line">	private PayContext mPayContext;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	public void onClick(View view) &#123;</div><div class="line">		switch(v.getId()) &#123;// 客户端来决定使用哪种支付策略</div><div class="line">			case R.id.wechat_pay:</div><div class="line">				mPayContext = new PayContext(new WechatPayStrategy());</div><div class="line">				break;</div><div class="line"></div><div class="line">			case R.id.wechat_pay:</div><div class="line">				mPayContext = new PayContext(new ALiPayStrategy());</div><div class="line">				break;</div><div class="line"></div><div class="line">			case R.id.wechat_pay:</div><div class="line">				mPayContext = new PayContext(BankCardPayStrategy());</div><div class="line">				break;</div><div class="line"></div><div class="line">			default:</div><div class="line">				mPayContext = new PayContext(new WechatPayStrategy());</div><div class="line">			    break;</div><div class="line">		&#125;</div><div class="line">		// 利用实际的支付策略对象进行支付</div><div class="line">		mPayContext.pay();</div><div class="line">	&#125; </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这样就实现了一个app内的支付功能，如果微信支付出现问题了，改动微信支付策略代码，支付宝支付出现问题，改动想要实现即可，职责单一。</p>
<p>如果PM有一天说：我们需要接入百付宝，京东支付。怎么办？<br>简单啊，实现相应的支付策略即可，完美适应需求变更，实现功能扩展。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>如果在开发某功能时，可能出现多种平等的选择，可以考虑使用策略模式实现。</p>
<p>好了，今天的《设计模式Android篇：策略模式》就到这里，请继续关注<a href="http://blog.csdn.net/xiong_it/article/details/54574020" target="_blank" rel="external">《Design Patterns in Android》</a>（设计模式Android篇）系列博文，欢迎各位读者朋友评论区拍砖交流，共同进步。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;刚过去的春节，大家有没有从“节后综合征”中痊愈满血呢？ 新年里给大家带来的第一篇是《设计模式Android篇：策略模式》。 本文将通俗易懂的给大家分享Android源码中的策略模式和如何在开发中实践策略模式。&lt;br&gt;
    
    </summary>
    
      <category term="Design Pattern" scheme="http://blog.michaelx.tech/categories/Design-Pattern/"/>
    
    
      <category term="Android" scheme="http://blog.michaelx.tech/tags/Android/"/>
    
      <category term="设计模式" scheme="http://blog.michaelx.tech/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="Design Pattern" scheme="http://blog.michaelx.tech/tags/Design-Pattern/"/>
    
      <category term="策略模式" scheme="http://blog.michaelx.tech/tags/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="Strategy" scheme="http://blog.michaelx.tech/tags/Strategy/"/>
    
  </entry>
  
  <entry>
    <title>Design Patterns in Android：单例模式</title>
    <link href="http://blog.michaelx.tech/2017-01/Design-Patterns-in-Android%EF%BC%9A%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    <id>http://blog.michaelx.tech/2017-01/Design-Patterns-in-Android：单例模式/</id>
    <published>2017-01-17T08:11:02.000Z</published>
    <updated>2017-05-03T08:21:21.752Z</updated>
    
    <content type="html"><![CDATA[<p>这是<a href="http://blog.csdn.net/Xiong_IT/article/details/54574020" target="_blank" rel="external">《Design Patterns in Android》</a>系列第一篇博文，那就从本开始和笔者一起领略Android开发中设计模式的魅力吧。<br>本系列《设计模式Android篇》博文将循序渐进的向读者讲解设计模式在Android开发的实践应用<br><a id="more"></a></p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>这是<a href="http://blog.csdn.net/Xiong_IT/article/details/54574020" target="_blank" rel="external">《Design Patterns in Android》</a>系列第一篇博文，那就从本开始和笔者一起领略Android开发中设计模式的魅力吧。<br>本系列《设计模式Android篇》博文将遵循以下模式，循序渐进的向读者讲解设计模式在Android开发的实践应用：</p>
<ol>
<li>给出设计模式的定义和使用场景</li>
<li>给出设计模式的UML类图</li>
<li>给出该设计模式的简单Java代码</li>
<li>给出该设计模式在Android源码中的应用分析</li>
<li><p>给出该设计模式在Android应用开发中的实践</p>
<p>本文原创作者xiong_it，博客链接：<a href="http://blog.csdn.net/xiong_it" target="_blank" rel="external">http://blog.csdn.net/xiong_it</a>，转载请注明出处。</p>
</li>
</ol>
<h1 id="单例模式定义"><a href="#单例模式定义" class="headerlink" title="单例模式定义"></a>单例模式定义</h1><blockquote>
<p>单例模式(Singleton pattern):确保一个类只有一个实例，并提供对该实例的全局访问。</p>
</blockquote>
<p>根据其定义，它的使用场景：当你需要创建一个对象，但是创建这个对象时需要消耗大量的系统资源，或者这个对象迫于某种原因只能在内存中存在一个实例的时候，单例模式也许是个不错的创建方案。</p>
<h1 id="单例模式UML类图"><a href="#单例模式UML类图" class="headerlink" title="单例模式UML类图"></a>单例模式UML类图</h1><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="http://img.blog.csdn.net/20170116175312086?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvWGlvbmdfSVQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述" title="">
                </div>
                <div class="image-caption">这里写图片描述</div>
            </figure>
<p>Singleton类作为单例类，它耦合了自身成员变量，并对外提供了一个公开方法getInstance()对instance对象的全局访问。</p>
<h1 id="单例模式代码示例"><a href="#单例模式代码示例" class="headerlink" title="单例模式代码示例"></a>单例模式代码示例</h1><p>众所周知，单例模式有多个变种，但是最常见的还是“饿汉式”及“懒汉式”2种。本处示例代码以线程安全的饿汉式举例。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</div><div class="line">	<span class="keyword">private</span> <span class="keyword">static</span> Singleton sInstance = <span class="keyword">new</span> Singleton();</div><div class="line">	</div><div class="line">	<span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="keyword">super</span>();</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="keyword">if</span>(sInstance == <span class="keyword">null</span>) &#123;</div><div class="line">			sInstance = <span class="keyword">new</span> Singleton();</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">return</span> sInstance;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>单例模式注意事项主要有3点：</p>
<ul>
<li>如果处于多线程环境，注意保持线程安全，不然就无法保证单例了</li>
<li>单例模式的默认构造方法的修饰符需改为private，只能类内部访问，确保外部不能直接new出该实例</li>
<li>单例模式需要提供一个全局访问入口，这个入口通常以getInstance()的public静态方法形式呈现</li>
</ul>
<h1 id="Android源码中的单例模式"><a href="#Android源码中的单例模式" class="headerlink" title="Android源码中的单例模式"></a>Android源码中的单例模式</h1><p>InputMethodManager是用来管理输入法和软键盘状态的关键类，它就是源码中一个单例模式应用的典型案例。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">public final classs InputMethodManager &#123;</div><div class="line"></div><div class="line">	/*...</div><div class="line">	省略代码，保留关键代码</div><div class="line">	...*/</div><div class="line">	static InputMethodManager sInstance;</div><div class="line">	</div><div class="line">	InputMethodManager(IInputMethodManager service, Looper looper) &#123;</div><div class="line">        mService = service;</div><div class="line">        mMainLooper = looper;</div><div class="line">        mH = new H(looper);</div><div class="line">        mIInputContext = new ControlledInputConnectionWrapper(looper,</div><div class="line">                mDummyInputConnection, this);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">	/**</div><div class="line">     * Retrieve the global InputMethodManager instance, creating it if it</div><div class="line">     * doesn&apos;t already exist.</div><div class="line">     * @hide</div><div class="line">     */</div><div class="line">    public static InputMethodManager getInstance() &#123;</div><div class="line">        synchronized (InputMethodManager.class) &#123;</div><div class="line">            if (sInstance == null) &#123;</div><div class="line">                IBinder b = ServiceManager.getService(Context.INPUT_METHOD_SERVICE);</div><div class="line">                IInputMethodManager service = IInputMethodManager.Stub.asInterface(b);</div><div class="line">                sInstance = new InputMethodManager(service, Looper.getMainLooper());</div><div class="line">            &#125;</div><div class="line">            return sInstance;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>从代码中，我们可以看到，InputMethodManager中有一个非公开的静态成员变量sInstance,它的构造方法也是非公开的，但是它对外（framwork层）提供了一个public的静态方法getInstance(Context)来对外提供单例对象，当该对象不存在时，就通过进程间通讯创建一个对象。<br>我们试想一下，假如它不是单例的话，在不同的应用中大家都可以自由创建该对象，该对象又极容易造成内存泄漏，创建N个InputMethodManager实例的话，你的Android手机该卡成什么鬼样子？？</p>
<blockquote>
<p>延伸阅读:<a href="https://zhuanlan.zhihu.com/p/20828861" target="_blank" rel="external">《Android InputMethodManager 导致的内存泄露及解决方案》</a></p>
</blockquote>
<p>所以说，InputMethodManager做成单例是一个明智的选择，实际上，除了InputMethodManager，直接操作系统资源的许多??Manager都是采用了单例模式来创建，比如AccessibilityManager，InputManager，LayoutInflater，BulutoothManager等。<br>不过他们的单例模式实现多种多样，其中LayoutInflater及许多其他Manager是采用集合缓存的形式的实现，第一次getSystemService(String)获取LayouInflater对象时，系统会通过ServiceFetcher创建一个对象并缓存到系统服务列表中，第二次获取时，直接从列表中得到该对象，并不再二次创建，确保单例。</p>
<h1 id="Android开发中的单例实践"><a href="#Android开发中的单例实践" class="headerlink" title="Android开发中的单例实践"></a>Android开发中的单例实践</h1><p>大家用过Universal-Image-Loader吗？没用过也没关系，使用<a href="https://github.com/nostra13/Android-Universal-Image-Loader" target="_blank" rel="external">UIL</a>加载一张图片非常简单：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ImageLoader.getInstance().displayImage(imageUrl, imageView);</div></pre></td></tr></table></figure>
<p>很眼熟，对不对？其实，这里ImageLoader对象的创建就是采用了单例模式的实现。<br>假如它不是单例实现呢？每次用都初始化一次吗？每次都创建一个新的对象吗？显然这是很浪费资源的一件事，所以ImageLoader是采用了单例模式来创建一个对象，以后用的时候还是复用那个对象，保证了UIL API的易用性，同时也兼顾了系统资源的合理利用。<br>ImageLoader的单例实现代码是<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">public class ImageLoader &#123;</div><div class="line">	/*</div><div class="line">	...</div><div class="line">	省略代码，保留关键代码</div><div class="line">	...</div><div class="line">	*/</div><div class="line">	private volatile static ImageLoader instance;</div><div class="line"></div><div class="line">	protected ImageLoader() &#123;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	/** Returns singleton class instance */</div><div class="line">	public static ImageLoader getInstance() &#123;</div><div class="line">		if (instance == null) &#123;</div><div class="line">			synchronized (ImageLoader.class) &#123;</div><div class="line">				if (instance == null) &#123;</div><div class="line">					instance = new ImageLoader();</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		return instance;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<pre><code>volatile关键字修饰的变量，一次只能有一个线程操作该变量，保证线程安全。
</code></pre><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>当你的某个类多次创建很耗资源，或者你的某个类对象你只希望它存在一个实例对象在内存中时，请考虑单例模式。</p>
<p>好了，今天的《设计模式Android篇：单例模式》就到这里，请继续关注<a href="http://blog.csdn.net/xiong_it/article/details/54574020" target="_blank" rel="external">《Design Patterns in Android》</a>（设计模式Android篇）系列博文，欢迎各位读者朋友评论区拍砖交流，共同进步。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这是&lt;a href=&quot;http://blog.csdn.net/Xiong_IT/article/details/54574020&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;《Design Patterns in Android》&lt;/a&gt;系列第一篇博文，那就从本开始和笔者一起领略Android开发中设计模式的魅力吧。&lt;br&gt;本系列《设计模式Android篇》博文将循序渐进的向读者讲解设计模式在Android开发的实践应用&lt;br&gt;
    
    </summary>
    
      <category term="Design Pattern" scheme="http://blog.michaelx.tech/categories/Design-Pattern/"/>
    
    
      <category term="Android" scheme="http://blog.michaelx.tech/tags/Android/"/>
    
      <category term="设计模式" scheme="http://blog.michaelx.tech/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="Design Pattern" scheme="http://blog.michaelx.tech/tags/Design-Pattern/"/>
    
      <category term="单例模式" scheme="http://blog.michaelx.tech/tags/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="Singleton" scheme="http://blog.michaelx.tech/tags/Singleton/"/>
    
  </entry>
  
  <entry>
    <title>Design Patterns in Android：目录纲要</title>
    <link href="http://blog.michaelx.tech/2017-01/Design-Patterns-in-Android%EF%BC%9A%E7%9B%AE%E5%BD%95%E7%BA%B2%E8%A6%81/"/>
    <id>http://blog.michaelx.tech/2017-01/Design-Patterns-in-Android：目录纲要/</id>
    <published>2017-01-17T07:14:34.000Z</published>
    <updated>2017-05-03T08:21:21.752Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>继<a href="http://blog.csdn.net/xiong_it/article/details/53467684" target="_blank" rel="external">《设计模式系列：OOP设计6大原则》</a>之后，博主自此将“间歇性”更新《Design Patterns in Android》（设计模式Android篇），旨在总结自己作为一名Android开发者，在摸索设计模式的过程中爬过的坑，因为很多设计模式的博文，书籍都是针对Java场景的，为了帮助一些Android开发者更贴切的理解和应用设计模式，博文将描述在Android源码中存在的设计模式，以及Android项目如何实践设计模式，将笔者在Android项目实践这些设计模式的心得体会，所得所想以文字的形式展现在读者朋友的眼前，也希望能够和广大的读者有更多的交流，促使自身进步。</p>
<blockquote>
<p>间歇性：<br>1、笔者对于23种设计模式也不是全部了解,并没有全部实践过，只能根据自己一些经验来描述一些实践过或者接触过的模式<br>2、笔者中途也会更新其他博文，与读者分享</p>
</blockquote>
<pre><code>本文作者xiong_it，博客链接：http://blog.csdn.net/xiong_it。转载请注明出处。
</code></pre><h1 id="什么是设计模式"><a href="#什么是设计模式" class="headerlink" title="什么是设计模式"></a>什么是设计模式</h1><p>在分享设计模式in Android之前，我们先来看下“设计模式”的定义</p>
<blockquote>
<p>在软件工程中，设计模式（design pattern）是对软件设计中普遍存在（反复出现）的各种问题，所提出的解决方案。-<a href="https://zh.wikipedia.org/wiki/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F_%28%E8%AE%A1%E7%AE%97%E6%9C%BA%29" target="_blank" rel="external">维基百科《设计模式 (计算机)》</a></p>
</blockquote>
<p>设计模式这个术语是由埃里希·伽玛（Erich Gamma）等人在1990年代从建筑设计领域引入到计算机科学的。并在1994年，埃里希·伽玛（Erich Gamma）, Richard Helm, Ralph Johnson，John Vlissides“四人帮”（Gang of Four，GoF）著成《设计模式：可复用面向对象软件的基础》为人所熟知并开始广泛流传。</p>
<p>也就是说，设计模式是一种软件编写过程中，解决编程问题的一种可复用的，有规矩可遵循的方案。</p>
<p>快速了解常用23中设计模式，<a href="http://blog.csdn.net/xiong_it/article/details/43445799" target="_blank" rel="external">《设计模式教你追MM》</a></p>
<h1 id="23种设计模式分类"><a href="#23种设计模式分类" class="headerlink" title="23种设计模式分类"></a>23种设计模式分类</h1><p>根据设计模式的使用场景，大概可分为3类：</p>
<h2 id="创建型"><a href="#创建型" class="headerlink" title="创建型"></a>创建型</h2><p>处理如何创建实例、对象。</p>
<ul>
<li><a href="http://blog.csdn.net/xiong_it/article/details/54575474" target="_blank" rel="external">单例模式(Singleton pattern)</a></li>
<li>原型模式(Prototype pattern)</li>
<li>建造者/构造器模式(Builder Pattern)</li>
<li>工厂方法模式(Factory Method pattern)</li>
<li>抽象工厂模式(Abstact Factory)</li>
</ul>
<h2 id="结构型"><a href="#结构型" class="headerlink" title="结构型"></a>结构型</h2><p>处理类及对象的复合关系。</p>
<ul>
<li>适配器模式(Adapter pattern)</li>
<li>桥接模式(Bridge pattern)</li>
<li>组合模式(Composite pattern)</li>
<li>装饰模式(Decorator pattern)</li>
<li>享元模式(Flyweight pattern)</li>
<li>代理模式(Proxy pattern)</li>
</ul>
<h2 id="行为型"><a href="#行为型" class="headerlink" title="行为型"></a>行为型</h2><p> 处理类/对象之间的转换，通讯。</p>
<ul>
<li><a href="http://blog.csdn.net/xiong_it/article/details/54574746" target="_blank" rel="external">策略模式(Strategy pattern)</a></li>
<li><a href="http://blog.csdn.net/xiong_it/article/details/54575479" target="_blank" rel="external">模板方法模式(Template method pattern)</a></li>
<li>职责链模式(Chain-of-responsibility pattern)</li>
<li>命令模式(Command pattern)</li>
<li>解释器模式(Interpreter pattern)</li>
<li>迭代器模式(Iterator pattern)</li>
<li>仲裁器/中介者模式(Mediator pattern)</li>
<li>备忘录模式(Memento pattern)</li>
<li>观察者(模式Observer pattern)</li>
<li>状态模式(State pattern)</li>
<li>参观者/访问者模式(Visitor)</li>
</ul>
<h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>如上，23种设计模式，各有各的使用场景，应用适当，可以使得代码扩展性大大提高，有利于后期需求变更和功能扩展及代码维护，带有链接的模式表示笔者已有介绍该模式在Android开发中的相关博文。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>维基百科：<a href="https://zh.wikipedia.org/wiki/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F_%28%E8%AE%A1%E7%AE%97%E6%9C%BA%29" target="_blank" rel="external">《设计模式（计算机）》</a>，<a href="https://zh.wikipedia.org/wiki/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%9A%E5%8F%AF%E5%A4%8D%E7%94%A8%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BD%AF%E4%BB%B6%E7%9A%84%E5%9F%BA%E7%A1%80" target="_blank" rel="external">《设计模式：可复用面向对象软件的基础》</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;继&lt;a href=&quot;http://blog.csdn.net/xiong_it/article/details/53467684&quot; targ
    
    </summary>
    
      <category term="Design Pattern" scheme="http://blog.michaelx.tech/categories/Design-Pattern/"/>
    
    
      <category term="Android" scheme="http://blog.michaelx.tech/tags/Android/"/>
    
      <category term="设计模式" scheme="http://blog.michaelx.tech/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="Design Pattern" scheme="http://blog.michaelx.tech/tags/Design-Pattern/"/>
    
  </entry>
  
  <entry>
    <title>设计模式系列：OOP设计6大原则</title>
    <link href="http://blog.michaelx.tech/2017-01/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%B3%BB%E5%88%97%EF%BC%9AOOP%E8%AE%BE%E8%AE%A16%E5%A4%A7%E5%8E%9F%E5%88%99/"/>
    <id>http://blog.michaelx.tech/2017-01/设计模式系列：OOP设计6大原则/</id>
    <published>2017-01-13T02:39:20.000Z</published>
    <updated>2017-05-03T08:21:21.756Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>相信有过开发经验的人都有过这种体验：让你接手一个的项目，2种情况。A.这个项目已经被好几个人，甚至好几代程序员开发维护过；B.这个项目等待你的全新开发。不给你设时间期限，你更愿意选择哪一个？我相信99.9%的人都会选择B这种开发模式。有木有？？<br>Why？因为不想改一个bug引起n个bug。说到底，就是因为已有的项目架构没有做好，或者没有适时的做架构调整，假如你接手的是旧代码，可能为了添加一个功能，因为架构不具备扩展性，你也许只能在原有的基础上修改几行代码，甚至修改几百上千行代码来达到目的，以此来埋下诸多隐患待下一个接盘侠搞定。那么就引出了今天的话题？什么样的代码才具备可扩展性呢？</p>
<pre><code>本文作者xiong_it，博客链接：http://blog.csdn.net/xiong_it。转载请注明出处。
</code></pre><h2 id="Open-Close-Principle"><a href="#Open-Close-Principle" class="headerlink" title="Open Close Principle"></a>Open Close Principle</h2><blockquote>
<p>OCP原则（开闭原则）：一个软件实体如类、模块和函数应该对扩展开放，对修改关闭。</p>
</blockquote>
<p>wtf???太抽象了！！！在笔者的理解中，OCP是6大原则的最高纲领，所以才如此抽象，晦涩难懂。用面向对象的语言来讲，OCP是一个最抽象的接口，而其余的5大原则只是OCP的子类接口，他们一起定义了OOP世界的开发标准，常用的23中设计模式更是只能算作这6大原则的实现抽象类，咱们开发的代码实践才是真正的具体子类。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">public interface OCP &#123;</div><div class="line">	void openExtention();</div><div class="line">	void closeModifiability();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>Q:What is OCP？<br>A:OCP是啥咧？它告诉我们，咱们编写的代码应该面向扩展开放，而尽量不要通过修改现有代码来拥抱需求变更。这里，代码可以指的是一个功能模块，类，或者方法。<br>Q:Why do we need to follow this principle？<br>A:我们为什么要遵循OCP原则呢？地球人都知道代码后期需求变更的痛苦，如果不利用扩展来适应变更，那迎来的将是代码被修改的千疮百孔。<br>Q:How do we practice this principle？<br>A:我们如何实践这条原则？能用抽象类的别用具体类，能用接口的别用抽象类。总之一句：尽量面向接口编程。这里之所以说“尽量”是因为凡事都有度，别让你来个hello world你还给整个接口再实现。</p>
<p><strong>talk is cheap，show your the code.</strong></p>
<pre><code>需求：老王开车去东北。
</code></pre><p>简单，开撸。</p>
<p>老王来了，大家藏好自己媳妇儿。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">public class Laowang &#123;</div><div class="line">	private Car car;</div><div class="line">	private DongBei dongbei;</div><div class="line"></div><div class="line">	...</div><div class="line">	getter() &amp; setter()</div><div class="line">	...</div><div class="line"></div><div class="line">	public void drive() &#123;</div><div class="line">		car.goto(dongbei);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>要车就给你一辆咯</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">public class Car &#123;</div><div class="line">	public void goto(DongBei dongbei) &#123;</div><div class="line">		System.out.println(“要去东北咯，啦啦啦”);</div><div class="line">		// 模拟开车旅途消耗时间。10s就到东北了，开的可够快的啊！司机之前是开飞机的吗？</div><div class="line">		Thread.getCurrentThread().sleep(10 * 1000);</div><div class="line">		System.out.println(“目的地东北到了”);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>东北到了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public class DongBei &#123;</div><div class="line">	private String address = &quot;东北那旮沓儿&quot;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>老司机要发车了，赶紧打卡上车。滴，学生卡，咳咳咳，拿错卡了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">public static void main(String[] args) &#123;</div><div class="line">	Car car = new Car();</div><div class="line">	Laowang wang = new Laowang();</div><div class="line">	wang.setCar(car);</div><div class="line">	DongBei dongbei = new DongBei();</div><div class="line">	wang.setDongbei(dongbei);</div><div class="line">	wang.drive();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Perfect，完美！<br>现在需求变了，老王实现了2017年定下的小目标，挣了1个亿，买了架私人飞机，他不想开车去东北了，太low，他要开飞机去东北。</p>
<pre><code>需求2：老王开飞机去东北
</code></pre><p>简单，给老王加个属性，加几个方法就实现了嘛？代码就不撸了。<br>OK，又是一次完美变化！？<br>需求又变了，老张和老王是穿一条裤裆长大的发小，老张看老王这都开上飞机了，他的车是不是可以借来开一开？</p>
<pre><code>需求3：老张开车去东北
</code></pre><p>这，这，这，简单，重新撸一遍老王在需求1的代码就行了，不就改个名的事吗？<br>来来来，需求又变了，老张有急事去东北，老王就把飞机也借给老张用了。</p>
<pre><code>需求4：老张开飞机去东北
</code></pre><p>这，这，这，这，这，这，简单，把老王在需求2的代码重撸一遍就是了。<br>来来来，需求又变了，老王这回不去东北了，他想开飞机去广东那儿去探望下老丈人，顺便兜兜风。</p>
<pre><code>需求5：老王开飞机去广东
需求6：老张开车去广东
需求7：老王要开飞机去美国
需求8：小王要开车去西藏
需求...
</code></pre><p>这，这，这，这这这，R&amp;D小哥一口老血喷在屏幕上，卒，享年25岁。</p>
<p>在这里，笔者建议，将人物，交通工具，目的地抽象化，接口化，就可以适应需求的频繁变更了。</p>
<p>上类图<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="http://img.blog.csdn.net/20170111203335703?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvWGlvbmdfSVQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="OCP" title="">
                </div>
                <div class="image-caption">OCP</div>
            </figure><br>客户端代码作如下调整：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">public static void main(String[] args) &#123;</div><div class="line">	// 想用地上开的交通工具出行，好，那就new个车给你开</div><div class="line">	ITransportation car = new Car();</div><div class="line">	// 这次是老王要出门</div><div class="line">	Person wang = new Laowang();</div><div class="line">	// 老王选择开车出行</div><div class="line">	wang.setTransportation(car);</div><div class="line">	// 老王目的地是东北</div><div class="line">	AbsDestination dongbei = new DongBei();</div><div class="line">	dongbei.setAddressName(&quot;东北&quot;);</div><div class="line">	wang.setDestination(dongbei);</div><div class="line">	// 老司机开着车就出发了</div><div class="line">	wang.startOff();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>老王的代码如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">public class Laowang extends Person&#123;</div><div class="line">	...</div><div class="line">	public void startOff() &#123;</div><div class="line">		this.transportation.transport();</div><div class="line">		System.out.println(&quot;出发咯&quot;);</div><div class="line">		//thread.sleep();</div><div class="line">		System.out.println(&quot;目的地&quot; + this.destination.getAddressName() +&quot;到了.&quot;);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>运行结果是：</p>
<pre><code>出发咯
目的地东北到了.
</code></pre><p>现在，假如要做如上一些需求变更，在需求的变更过程中，客户端的代码变化是不是小多了呢？</p>
<blockquote>
<p> 注意：开闭原则对扩展开放，对修改关闭，并不意味着不做任何修改，低层次模块的变化，必然要有高层模块进行耦合，否则就是一个孤立无意义的代码片段。<br>在业务规则改变的情况下高层模块必须有部分改变以适应新业务，改变要尽量地少，放置变化风险的扩散<br>—秦小波《设计模式之禅》</p>
</blockquote>
<h2 id="Single-Responsibility-Principle"><a href="#Single-Responsibility-Principle" class="headerlink" title="Single Responsibility Principle"></a>Single Responsibility Principle</h2><blockquote>
<p> SRP原则（职责单一原则）:应该有且只有一个原因引起类的变更。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public interface SRP extends OCP &#123;</div><div class="line">	void onlyDoOneThing();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
</blockquote>
<p>通俗点来讲，一个类，一个方法只应该做一件事情。<br>举2个栗子：<br>1.当一个类A有R1，R2两个职责时，当R1的职责发生变更时，你需要修改类A，当R2发生变更时，你又需要修改类A，这时，已经有2个原因可能会引起类的变化了，类A就已经职责不单一了，就需要职责拆分，比如拆分成类A1，A2：A1类负责R1职责，A2类负责R2职责了。<br>2.再比如有一个方法M，它即负责计算和打印两个职责<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">public void M(int a, int b) &#123;</div><div class="line">	int c = 0;</div><div class="line">	c = a + b;</div><div class="line">	</div><div class="line">    System.out.println(&quot;打印的是 = &quot; + c); </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>有一天，你想要修改下计算规则，改为<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">c=a+b+1;</div></pre></td></tr></table></figure></p>
<p>此时，你修改了方法M。<br>又一天，你想修改下打印规则，改为<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">System.out.println(&quot;打印的是 = &quot; + （c+1）);</div></pre></td></tr></table></figure></p>
<p>你又修改了方法M，此时，超过了2个原因让你去修改它，所以这个方法应该拆分为待返回值得计算calc方法和打印print两个方法。<br>似的每个方法都只做一件事情。</p>
<p>那它是如何体现扩展性的呢？<br>拿一个Android中最常见的ImageLoader的设计来举例子，ImageLoader主要需要实现2个功能，下载图片，缓存图片。<br>假如，我们把所有的功能全部放在一个ImageLoader类中，假设下载要改方式呢？缓存要改策略呢？你通通要改ImageLoader，你如何保证修改某个功能的过程中另一个功能依旧完好，没被污染？拆分职责，使用ImageCache接口及其子类实现进行缓存，和ImageLoader建立关联，职责单一了，你再在每个单一的职责类里面去修改相关代码，这样其他功能代码被污染的概率大大降低。</p>
<p>当然，这里只是随意举的例子，划分单一职责这个度很难把握，每个人都需要根据自身情况和项目情况来进行判断。</p>
<h2 id="Liskov-Substitution-Principle"><a href="#Liskov-Substitution-Principle" class="headerlink" title="Liskov Substitution Principle"></a>Liskov Substitution Principle</h2><blockquote>
<p>OCP原则(里氏替换原则)：所有引用基类的地方必须能透明地使用其子类的对象<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public interface LSP extends OCP &#123;</div><div class="line">	void liskovSubstitutionPrinciple();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
</blockquote>
<p>通俗点讲：只要父类能出现的地方子类就可以出现，而且替换为子类也不产生任何异常错误，反之则不然。这主要体现在，我们经常使用抽象类/基类做为方法参数，具体使用哪个子类作为参数传入进去，由调用者决定。</p>
<p>这条原则包含以下几个方面：</p>
<ul>
<li>子类必须完全实现父类的方法</li>
<li>子类可以有自己的个性外观（属性）和行为（方法）</li>
<li>覆盖或者实现父类方法时，参数可以被放大。即父类的某个方法参数为HashMap时，子类参数可以是HashMap，也可以是Map或者更大</li>
<li>覆盖或者实现父类的方法时，返回结果可以被缩小。即父类的某个方法返回类型是Map，子类可以是Map，也可以是HashMap或者更小。</li>
</ul>
<h2 id="Dependence-Inversion-Principle"><a href="#Dependence-Inversion-Principle" class="headerlink" title="Dependence Inversion Principle"></a>Dependence Inversion Principle</h2><blockquote>
<p>DIP原则（依赖倒置原则）：高层模块不要依赖低层模块，所以依赖都应该是抽象的，抽象不应该依赖于具体细节而，具体细节应该依赖于抽象</p>
</blockquote>
<p>底层模块：不可分割的原子逻辑就是低层模块<br>高层模块：低层模块的组装合成后就是高层模块</p>
<p>抽象：Java中体现为基类，抽象类，接口，而不单指抽象类<br>细节：体现为子类，实现类</p>
<p>通俗点讲，该原则包含以下几点要素：</p>
<ul>
<li>模块间的依赖应该通过抽象发生，具体实现类之间不应该建立依赖关系</li>
<li>接口或者抽象类不依赖于实现类，否则就失去了抽象的意义</li>
<li>实现类依赖于接口或者抽象类</li>
</ul>
<p>总结起来，一句话：”<strong>面向接口编程</strong>“。</p>
<h2 id="Interface-Segregation-Principle"><a href="#Interface-Segregation-Principle" class="headerlink" title="Interface-Segregation Principle"></a>Interface-Segregation Principle</h2><blockquote>
<p>ISP原则（接口隔离原则）:客户端不应该依赖它不需要的接口；类间的依赖应该建立在最小的接口上</p>
</blockquote>
<p>通俗点讲：使用接口时应该建立单一接口，不要建立臃肿庞大的接口，尽量给调用者提供专门的接口，而非多功能接口。</p>
<p>这里我想举个例子就是Android中的事件处理Listener设计，大家都知道，我们想给button添加点击事件时，可以使用如下代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">button.setOnClickListener(clickListener);</div></pre></td></tr></table></figure>
<p>想给它添加长按事件时，可以使用如下代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">button.setOnLongClickListener(longClickListener);</div></pre></td></tr></table></figure>
<p>还有其他比如OnTouchListener等等等事件接口，它为什么不直接提供一个通用的接口IListener呢？然后回调所有的事件给调用者处理，而要提供这么多独立的接口，这就是遵循了ISP原则的结果，每个接口最小化了，Activity/button作为调用者，我可以选择性的去处理我想处理的事件，不关心的事件Listener我就不去处理，依赖。</p>
<h2 id="Low-of-Demeter"><a href="#Low-of-Demeter" class="headerlink" title="Low of Demeter"></a>Low of Demeter</h2><blockquote>
<p>LoD法则（迪米特法则）：又称最少知识原则（Least Knowledge Principle， LKP），一个对象应该对其他对象有最少的了解。</p>
</blockquote>
<p>通俗点讲：一个类应该对自己需要耦合或者调用的类知道越少越好，被耦合或者调用的类内部和我没有关系，我不需要的东西你就别public了吧。</p>
<p>迪米特法则包含以下几点要素：</p>
<ul>
<li>只和朋友类交流：只耦合该耦合的类</li>
<li>朋友间也是有距离的：减少不该public的方法，向外提供一个简洁的访问</li>
<li>自家的方法就自己创建：只要该方法不会增加内部的负担，也不会增加类间耦合</li>
</ul>
<h2 id="感谢和参考"><a href="#感谢和参考" class="headerlink" title="感谢和参考"></a>感谢和参考</h2><p>秦小波：《设计模式之禅》<br>Mr.simple：《Android 源码设计模式解析与实战》<br>java-my-life:<a href="http://www.cnblogs.com/java-my-life/" target="_blank" rel="external">http://www.cnblogs.com/java-my-life/</a><br>…<br>…</p>
<h2 id="后话"><a href="#后话" class="headerlink" title="后话"></a>后话</h2><p>规则只是规则，大家不应该死守规则，应该持辩证的态度去看待这6大原则，才能更好地达到实践应用的目的。<br>感谢以上作者和博客的规范化引导以及诸多博主的博客才渐渐让我懂得实践设计模式与应用架构。笔者将会未来陆续更新《设计模式系列》in Android博客，后续博客中，均参考了以上书籍和博客。欢迎各位朋友评论区点赞拍砖交流。</p>
]]></content>
    
    <summary type="html">
    
      相信有过开发经验的人都有过这种体验：让你接手一个的项目，2种情况。A.这个项目已经被好几个人，甚至好几代程序员开发维护过；B.这个项目等待你的全新开发。不给你设时间期限,你更愿意选择哪一个？我相信99.9%的人都会选择B这种开发模式。有木有？？Why？因为不想改一个bug引起n个bug。说到底，就是因为已有的项目架构没有做好，或者没有适时的做架构调整，假如你接手的是旧代码，可能为了添加一个功能，因为架构不具备扩展性，你也许只能在原有的基础上修改几行代码，甚至修改几百上千行代码来达到目的，以此来埋下诸多隐患待下一个接盘侠搞定。那么就引出了今天的话题？什么样的代码才具备可扩展性呢？
    
    </summary>
    
      <category term="Design Pattern" scheme="http://blog.michaelx.tech/categories/Design-Pattern/"/>
    
    
      <category term="设计模式" scheme="http://blog.michaelx.tech/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="Design Pattern" scheme="http://blog.michaelx.tech/tags/Design-Pattern/"/>
    
      <category term="6大原则" scheme="http://blog.michaelx.tech/tags/6%E5%A4%A7%E5%8E%9F%E5%88%99/"/>
    
      <category term="OOP" scheme="http://blog.michaelx.tech/tags/OOP/"/>
    
  </entry>
  
</feed>
